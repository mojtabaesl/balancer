/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */


/** WithRequired type helpers */
type WithRequired<T, K extends keyof T> = T & { [P in K]-?: T[P] };

export interface paths {
  "/domains": {
    /**
     * Get the list of domains
     * @description Leaving the 'search' empty, will return all domains. Otherwise, it will filter domains containing the search keyword.
     */
    get: operations["domains.index"];
  };
  "/domains/dns-service": {
    /** Create new domain */
    post: operations["domains.store"];
  };
  "/domains/{domain}": {
    /** Get information of the domain */
    get: operations["domains.show"];
    /** Remove the domain */
    delete: operations["domains.destroy"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
  };
  "/domains/{domain}/ns-keys": {
    /** Set custom NS records for the domain */
    put: operations["domains.nameservers.set"];
    /** Reset custom Nameserver keys to the default values for the domain */
    delete: operations["domains.nameservers.reset"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
  };
  "/domains/{domain}/ns-keys/check": {
    /** Check NS to find whether domain is activated */
    get: operations["domains.nameservers.check"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
  };
  "/domains/{domain}/dns-service/check-ns": {
    /**
     * Deprecated in favor /ns-keys/check
     * @deprecated
     */
    put: operations["domains.nameservers.deprecated-check"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
  };
  "/domains/{domain}/ns-keys/use-optional-keys": {
    /** Use optional NS keys */
    post: operations["domains.nameservers.optional"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
  };
  "/domains/{domain}/cname-setup/custom": {
    /** Set a custom record for using CNAME Setup */
    put: operations["domains.cname-setup.set"];
    /** Reset the custom record of CNAME Setup to the default value */
    delete: operations["domains.cname-setup.reset"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
  };
  "/domains/{domain}/cname-setup/convert": {
    /** Convert domain setup to cname */
    post: operations["domains.cname-setup.convert"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
  };
  "/domains/{domain}/cname-setup/check": {
    /** Check Cname Setup to find whether domain is activated */
    get: operations["domains.cname-setup.check"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
  };
  "/domains/{domain}/clone": {
    /** Clone a domain config from another one */
    post: operations["domains.clone"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
  };
  "/domains/{domain}/regenerate": {
    /** Regenerate domain settings for edge servers */
    post: operations["domains.regenerate"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
  };
  "/domains/transfer": {
    /** Get the list of pending transfers */
    get: operations["domains.transfer.index"];
  };
  "/domains/{domain}/transfer": {
    /** Transfer domain to another account */
    post: operations["domains.transfer.store"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
  };
  "/domains/transfer/change-status": {
    /** Accept or cancel transferring a domain */
    post: operations["domains.transfer.update"];
  };
  "/plans": {
    /** Get the list of feature defintions for plans based on different sets */
    get: operations["plans.index"];
  };
  "/domains/{domain}/plans": {
    /** Get the list of feature defintions for plans based on different sets */
    get: operations["domains.plans"];
  };
  "/domains/{domain}/plan": {
    /** Update the domain's plan */
    put: operations["domains.plans.update"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
  };
  "/domains/{domain}/plan/violations": {
    /** Get violations based on plans */
    get: operations["domains.plans.violations"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
  };
  "/domains/{domain}/plan/usages": {
    /** Get usages based on features and an estimated cost */
    get: operations["domains.plans.usages"];
    parameters: {
      query?: {
        target_plan?: components["schemas"]["Plan"];
      };
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
  };
  "/domains/{domain}/dns-records": {
    /** Get list of DNS records */
    get: operations["dns-records.index"];
    /** Create new DNS record */
    post: operations["dns-records.store"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
  };
  "/domains/{domain}/dns-records/{id}": {
    /** Get information of a record */
    get: operations["dns-records.show"];
    /** Update a DNS record */
    put: operations["dns-records.update"];
    /** Remove a DNS record */
    delete: operations["dns-records.destroy"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        id: components["parameters"]["DnsRecordId"];
      };
    };
  };
  "/domains/{domain}/dns-records/{id}/cloud": {
    /** Toggle cloud status (To proxy or not proxy, that's the question!) */
    put: operations["dns-records.cloud"];
  };
  "/domains/{domain}/dns-records/import": {
    /** Import DNS records using BIND file */
    post: operations["dns-records.import"];
  };
  "/domains/{domain}/dns-records/dnssec": {
    /** Get status of DNSSEC */
    get: operations["dns-records.dns-sec.show"];
  };
  "/domains/{domain}/dns-records/dnssec/actions": {
    /** Update DNSSEC status */
    put: operations["dns-records.dns-sec.update"];
  };
  "/domains/{domain}/caching": {
    /** Get caching settings */
    get: operations["caching.index"];
    /**
     * Purge CDN Cache
     * @deprecated
     * @description Purge CDN cache, either by URLs, tags, or the whole site.
     * Purge by tag is only available for domains with Professional plan or higher.
     */
    delete: operations["caching.deprecated_purge"];
    /** Update caching settings */
    patch: operations["caching.update"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
  };
  "/domains/{domain}/caching/purge": {
    /**
     * Purge CDN Cache
     * @description Purge CDN cache, either by URLs, tags, or the whole site.
     * Purge by tag is only available for domains with Professional plan or higher.
     */
    post: operations["caching.purge"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
  };
  "/domains/{domain}/purge-tags": {
    /**
     * Get domain's Purge tags
     * @deprecated
     * @description Returns last 100 purged tags sorted by recency.
     */
    get: operations["purge_tags.index"];
    /**
     * Delete a Domain's Purge tag
     * @deprecated
     */
    delete: operations["purge_tags.destroy"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
  };
  "/load-balancers/regions": {
    /** Get list of regions for load balancers */
    get: operations["load-balancers.regions.index"];
  };
  "/domains/{domain}/load-balancers/settings": {
    /** Get list of domain load balancer global settings */
    get: operations["load-balancers.settings.show"];
    /** Update domain's global load balancer settings */
    patch: operations["load-balancers.settings.update"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
  };
  "/domains/{domain}/load-balancers": {
    /** Get list of load balancers */
    get: operations["load-balancers.index"];
    /** Create a new load balancer */
    post: operations["load-balancers.store"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
  };
  "/domains/{domain}/load-balancers/{loadBalancerId}": {
    /** Get load balancer information */
    get: operations["load-balancers.show"];
    /** Update a load balancer */
    put: operations["load-balancers.updateWithPools"];
    /** Remove a load balancer */
    delete: operations["load-balancers.destroy"];
    /** Update a load balancer */
    patch: operations["load-balancers.update"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        loadBalancerId: components["parameters"]["LoadBalancerId"];
      };
    };
  };
  "/domains/{domain}/load-balancers/{loadBalancerId}/pools": {
    /** Get the list of pools of a load balancers */
    get: operations["load-balancers.pools.index"];
    /** Create a new pool for the load balancer */
    post: operations["load-balancers.pools.store"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        loadBalancerId: components["parameters"]["LoadBalancerId"];
      };
    };
  };
  "/domains/{domain}/load-balancers/{loadBalancerId}/prioritize": {
    /** Reorder the priority of load balancer pools */
    post: operations["load-balancers.prioritize_pool"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        loadBalancerId: components["parameters"]["LoadBalancerId"];
      };
    };
  };
  "/domains/{domain}/load-balancers/{loadBalancerId}/pools/{loadBalancerPoolId}": {
    /** Get load balancer pool information */
    get: operations["load-balancers.pools.show"];
    /** Update an existing load balancer pool with origins */
    put: operations["load-balancers.pools.update"];
    /** Remove a load balancer pool */
    delete: operations["load-balancers.pools.destroy"];
    /** Update an existing load balancer pool without origins */
    patch: operations["load-balancers.pools.updatePool"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        loadBalancerId: components["parameters"]["LoadBalancerId"];
        loadBalancerPoolId: components["parameters"]["LoadBalancerPoolId"];
      };
    };
  };
  "/domains/{domain}/load-balancers/{loadBalancerId}/pools/{loadBalancerPoolId}/origins": {
    /** Get list of origins of a pool */
    get: operations["load-balancers.pools.origins.index"];
    /** Create a new origin in the pool of the load balancer */
    post: operations["load-balancers.pools.origins.store"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        loadBalancerId: components["parameters"]["LoadBalancerId"];
        loadBalancerPoolId: components["parameters"]["LoadBalancerPoolId"];
      };
    };
  };
  "/domains/{domain}/load-balancers/{loadBalancerId}/pools/{loadBalancerPoolId}/origins/{loadBalancerPoolOriginId}": {
    /** Get load balancer origin information */
    get: operations["load-balancers.pools.origins.show"];
    /** Remove an origin from the pool of the load balancer */
    delete: operations["load-balancers.pools.origins.destroy"];
    /** Update an existing origin of the pool */
    patch: operations["load-balancers.pools.origins.update"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        loadBalancerId: components["parameters"]["LoadBalancerId"];
        loadBalancerPoolId: components["parameters"]["LoadBalancerPoolId"];
        loadBalancerPoolOriginId: components["parameters"]["LoadBalancerPoolOriginId"];
      };
    };
  };
  "/domains/{domain}/page-rules": {
    /** Get list of page-rules */
    get: operations["page-rules.index"];
    /** Create new page-rule */
    post: operations["page-rules.store"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
  };
  "/domains/{domain}/page-rules/{id}": {
    /** Get the page-rule's information */
    get: operations["page-rules.show"];
    /** Update the page-rule */
    put: operations["page-rules.update"];
    /** Delete the page-rule */
    delete: operations["page-rules.destroy"];
    /** Toggle status of the page-rule */
    patch: operations["page-rules.status.update"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        id: components["parameters"]["Id"];
      };
    };
  };
  "/domains/{domain}/page-rules/{id}/purge": {
    /** Purge the page-rule */
    delete: operations["page-rules.purge"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        id: components["parameters"]["Id"];
      };
    };
  };
  "/domains/{domain}/page-rules/{id}/diff": {
    /** Get the page-rule's exceptions */
    get: operations["page-rules.diff.show"];
    /** Update the page-rule's exceptions */
    patch: operations["page-rules.diff.update"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        id: components["parameters"]["Id"];
      };
    };
  };
  "/domains/{domain}/image-resize": {
    /** Get the content of image resize settings */
    get: operations["image-resize.show"];
    /** Update the content of image resize settings */
    patch: operations["image-resize.update"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
  };
  "/domains/{domain}/acceleration": {
    /** Get the content of acceleration settings */
    get: operations["acceleration.show"];
    /** Update the content of acceleration settings */
    patch: operations["acceleration.update"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
  };
  "/domains/{domain}/custom-pages": {
    /** Get list of custom pages */
    get: operations["custom-pages.show"];
    /** Update custom page */
    post: operations["custom-pages.update"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
  };
  "/domains/{domain}/settings/www-redirect": {
    /** Get redirect settings */
    get: operations["redirect.show"];
    /** Update redirect settings */
    put: operations["redirect.update"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
  };
  "/domains/{domain}/log-forwarders": {
    /** Show list of log forwarders for given domain */
    get: operations["log-forwarders.index"];
    /** Create new log forwarder */
    post: operations["log-forwarders.store"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
  };
  "/domains/{domain}/log-forwarders/{logForwarderId}": {
    /** Show a log forwarder's details based on given id */
    get: operations["log-forwarders.show"];
    /** Update a log forwarder */
    put: operations["log-forwarders.update"];
    /** Delete a log forwarder */
    delete: operations["log-forwarders.destroy"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
  };
  "/domains/{domain}/log-forwarders/{logForwarderId}/status": {
    /** Update a log forwarder's status */
    patch: operations["log-forwarders.update.status"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
  };
  "/domains/{domain}/transport-layer-proxies": {
    /** Show list of transport layer proxies for given domain */
    get: operations["transport-layer-proxies.index"];
    /** Create new transport layer proxy */
    post: operations["transport-layer-proxies.store"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
  };
  "/domains/{domain}/transport-layer-proxies/{transportLayerProxyId}": {
    /** Show a transport layer proxy's details based on given id */
    get: operations["transport-layer-proxies.show"];
    /** Update a transport layer proxy */
    put: operations["transport-layer-proxies.update"];
    /** delete a transport layer proxy */
    delete: operations["transport-layer-proxies.destroy"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        transportLayerProxyId: components["parameters"]["TransportLayerProxyId"];
      };
    };
  };
  "/domains/{domain}/email-forwardings/stats": {
    /** Show stats of domain's email forwarding */
    get: operations["email-forwardings.stats"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
  };
  "/domains/{domain}/email-forwardings/activate": {
    /** Activate email forwarding */
    post: operations["email-forwardings.activate"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
  };
  "/domains/{domain}/email-forwardings/deactivate": {
    /** Deactivate email forwarding */
    post: operations["email-forwardings.deactivate"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
  };
  "/domains/{domain}/email-forwardings/catch-all/activate": {
    /** Activate email forwarding catch all */
    post: operations["email-forwardings.catch_all.activate"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
  };
  "/domains/{domain}/email-forwardings/catch-all/deactivate": {
    /** Deactivate email forwarding catch all */
    post: operations["email-forwardings.catch_all.deactivate"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
  };
  "/domains/{domain}/email-forwardings/{emailForwardingId}/recipients": {
    /** List recipients of an email forwarding */
    get: operations["email-forwardings.recipients.index"];
    /** Create new recipient */
    post: operations["email-forwardings.recipients.store"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        emailForwardingId: components["parameters"]["EmailForwarding"];
      };
    };
  };
  "/domains/{domain}/email-forwardings/{emailForwardingId}/recipients/{emailForwardingRecipientId}": {
    /** Delete a recipient */
    delete: operations["email-forwardings.recipients.destroy"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        emailForwardingId: components["parameters"]["EmailForwarding"];
        emailForwardingRecipientId: components["parameters"]["EmailForwardingRecipient"];
      };
    };
  };
  "/domains/{domain}/email-forwardings/{emailForwardingId}/recipients/{emailForwardingRecipientId}/set-default": {
    /** Set default recipient */
    patch: operations["email-forwardings.recipients.set_default"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        emailForwardingId: components["parameters"]["EmailForwarding"];
        emailForwardingRecipientId: components["parameters"]["EmailForwardingRecipient"];
      };
    };
  };
  "/domains/{domain}/email-forwardings/{emailForwardingId}/recipients/{emailForwardingRecipientId}/verify": {
    /** Verify recipient */
    post: operations["email-forwardings.recipients.verify"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        emailForwardingId: components["parameters"]["EmailForwarding"];
        emailForwardingRecipientId: components["parameters"]["EmailForwardingRecipient"];
      };
    };
  };
  "/domains/{domain}/email-forwardings/{emailForwardingId}/recipients/{emailForwardingRecipientId}/resend-verification": {
    /** Resend Verification */
    post: operations["email-forwardings.recipients.resend_verification"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        emailForwardingId: components["parameters"]["EmailForwarding"];
        emailForwardingRecipientId: components["parameters"]["EmailForwardingRecipient"];
      };
    };
  };
  "/domains/{domain}/email-forwardings/{emailForwardingId}/aliases": {
    /** List of email forwarding aliases for given domain */
    get: operations["email-forwardings.aliases.index"];
    /** Create new alias */
    post: operations["email-forwardings.aliases.store"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        emailForwardingId: components["parameters"]["EmailForwarding"];
      };
    };
  };
  "/domains/{domain}/email-forwardings/{emailForwardingId}/aliases/{emailForwardingAliasId}": {
    /** Delete an alias */
    delete: operations["email-forwardings.aliases.destroy"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        emailForwardingId: components["parameters"]["EmailForwarding"];
        emailForwardingAliasId: components["parameters"]["EmailForwardingAlias"];
      };
    };
  };
  "/domains/{domain}/email-forwardings/{emailForwardingId}/aliases/{emailForwardingAliasId}/toggle-activation": {
    /** Toggle alias activation */
    patch: operations["email-forwardings.aliases.toggle_activation"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        emailForwardingId: components["parameters"]["EmailForwarding"];
        emailForwardingAliasId: components["parameters"]["EmailForwardingAlias"];
      };
    };
  };
  "/domains/{domain}/email-forwardings/{emailForwardingId}/aliases/{emailForwardingAliasId}/recipients": {
    /** Update alias recipients */
    patch: operations["email-forwardings.aliases.update_recipients"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        emailForwardingId: components["parameters"]["EmailForwarding"];
        emailForwardingAliasId: components["parameters"]["EmailForwardingAlias"];
      };
    };
  };
  "/domains/{domain}/troubleshoots": {
    /** Show list of troubleshoots for given domain */
    get: operations["troubleshoots.index"];
    /** Create new troubleshoot */
    post: operations["troubleshoots.store"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
  };
  "/domains/{domain}/troubleshoots/latest": {
    /** Show the latest troubleshoot for given domain */
    get: operations["troubleshoots.latest"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
  };
  "/domains/{domain}/reports/traffics": {
    /** Get traffic report for domain */
    get: operations["reports.traffics.total"];
  };
  "/domains/{domain}/reports/traffics/saved": {
    /** Get traffic saved to total pie chart */
    get: operations["reports.traffics.saved"];
  };
  "/domains/{domain}/reports/traffics/map": {
    /** Get traffic as geo-map */
    get: operations["reports.traffics.map"];
  };
  "/domains/{domain}/reports/visitors": {
    /** Get report of visitors for domain */
    get: operations["reports.visitors.index"];
  };
  "/domains/{domain}/reports/high-request-ips": {
    /** Get report of IPs with highest number of requests */
    get: operations["reports.visitors.high-request-ips"];
  };
  "/domains/{domain}/reports/response-time": {
    /** Get response time report */
    get: operations["reports.response-time.index"];
  };
  "/domains/{domain}/reports/status": {
    /** Get status codes pie chart */
    get: operations["reports.status.index"];
  };
  "/domains/{domain}/reports/status/summary": {
    /** Get an overview of status codes pie chart */
    get: operations["reports.status.summary"];
  };
  "/domains/{domain}/reports/error-logs": {
    /** Get list of errors */
    get: operations["reports.error-logs"];
  };
  "/domains/{domain}/reports/error-logs/chart": {
    /** Get chart view of errors */
    get: operations["reports.error-logs.chart"];
  };
  "/domains/{domain}/reports/error-log-details": {
    /**
     * Get detail of an error
     * @deprecated
     */
    get: operations["reports.error-log-details"];
  };
  "/domains/{domain}/reports/dns-requests": {
    /** Get response time report */
    get: operations["reports.dns.requests"];
  };
  "/domains/{domain}/reports/dns-geo": {
    /** Get DNS requests as geo-map */
    get: operations["reports.dns.geo"];
  };
  "/domains/{domain}/reports/attacks": {
    /** Get report of attacks */
    get: operations["reports.attacks.show"];
  };
  "/domains/{domain}/reports/attacks/list": {
    /** Get list of attacks details */
    get: operations["reports.attacks.index"];
  };
  "/domains/{domain}/reports/attacks/attackers": {
    /** Get list of attackers information */
    get: operations["reports.attacks.attackers"];
  };
  "/domains/{domain}/reports/attacks/map": {
    /** Get geo-map of attacks */
    get: operations["reports.attacks.map"];
  };
  "/domains/{domain}/reports/attacks/uri": {
    /** Get list of URLs under attack */
    get: operations["reports.attacks.uri"];
  };
  "/domains/{domain}/reports/transport-layer-proxies/{transportLayerProxyId}/traffics": {
    /** Get traffic report for transport layer proxy */
    get: operations["reports.transport_layer_proxies.traffics"];
  };
  "/bulk/reports/traffics": {
    /** Get traffic report for multiple domains */
    post: operations["bulk-reports.traffics.total"];
  };
  "/bulk/reports/visitors": {
    /** Get visitor report for multiple domains */
    post: operations["bulk-reports.visitors.total"];
  };
  "/domains/{domain}/firewall/settings": {
    /** Get domain's firewall configuration */
    get: operations["firewall.settings.index"];
    /** Update domain's firewall configuration */
    patch: operations["firewall.settings.update"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
  };
  "/domains/{domain}/firewall/rules": {
    /** Get domain's firewall rules */
    get: operations["firewall.rules.index"];
    /** Create new firewall rule */
    post: operations["firewall.rules.store"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
  };
  "/domains/{domain}/firewall/rules/{id}": {
    /** Get firewall rule information */
    get: operations["firewall.rules.show"];
    /** Delete firewall rule */
    delete: operations["firewall.rules.destroy"];
    /** Update the firewall rule */
    patch: operations["firewall.rules.update"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        id: components["parameters"]["Id"];
      };
    };
  };
  "/domains/{domain}/firewall/actions/reprioritize": {
    /**
     * Change priority of firewall rules
     * @description You can choose a firewall rule and request to put it after or before another rule.
     * You should only provide either after_rule_id or before_rule_id (and not both of them).
     */
    post: operations["firewall.reprioritize"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
  };
  "/waf": {
    /** Get WAF presets */
    get: operations["global.waf.index"];
  };
  "/waf/packages/{packageId}": {
    /** Get WAF package details */
    get: operations["global.waf.show_package"];
    parameters: {
      path: {
        packageId: components["parameters"]["PackageId"];
      };
    };
  };
  "/domains/{domain}/waf/settings": {
    /** Get WAF configuration */
    get: operations["waf.settings.index"];
    /** Configure WAF module of the domain */
    patch: operations["waf.settings.update"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
  };
  "/domains/{domain}/waf/actions/reconfigure": {
    /**
     * Reconfigure WAF module using a preset
     * @description It remove all existing WAF packages and configures packages as defined in the preset
     */
    post: operations["waf.reconfigure"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
  };
  "/domains/{domain}/waf/actions/reprioritize": {
    /**
     * Change priority of WAF rules
     * @description You can choose a WAF rule and request to put it after or before another rule.
     * You should only provide either after_rule_id or before_rule_id (and not both of them).
     */
    post: operations["waf.reprioritize"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
  };
  "/domains/{domain}/waf/actions/reprioritize-package": {
    /**
     * Change priority of WAF packages
     * @description You can choose a WAF package and request to put it after or before another one.
     * You should only provide either after_package_id or before_package_id (and not both of them).
     */
    post: operations["waf.package.reprioritize"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
  };
  "/domains/{domain}/waf/rules": {
    /** Get WAF Rules */
    get: operations["waf.rules.index"];
    /** Create new WAF rule */
    post: operations["waf.rules.store"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
  };
  "/domains/{domain}/waf/rules/{id}": {
    /** Get WAF rule information */
    get: operations["waf.rules.show"];
    /** Delete WAF rule */
    delete: operations["waf.rules.destroy"];
    /** Update the WAF rule */
    patch: operations["waf.rules.update"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        id: components["parameters"]["Id"];
      };
    };
  };
  "/domains/{domain}/waf/packages": {
    /**
     * Get WAF packages
     * @description By passing `available` parameter in query string, it will return available packages for this domain.
     * Otherwise it lists currently added packages.
     */
    get: operations["waf.packages.index"];
    /** Add new WAF package to domain */
    post: operations["waf.packages.store"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
  };
  "/domains/{domain}/waf/packages/{id}": {
    /** Get WAF package information */
    get: operations["waf.packages.show"];
    /** Delete WAF package from domain */
    delete: operations["waf.packages.destroy"];
    /** Update the WAF package */
    patch: operations["waf.packages.update"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        id: string;
      };
    };
  };
  "/domains/{domain}/ddos/settings": {
    /** Get DDoS protection settings */
    get: operations["ddos.settings.index"];
    /** Update domain's DDoS protection configuration */
    patch: operations["ddos.settings.update"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
  };
  "/domains/{domain}/ddos/rules": {
    /** Get DDoS Protection Rules */
    get: operations["ddos.rules.index"];
    /** Create new DDoS protection rule */
    post: operations["ddos.rules.store"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
  };
  "/domains/{domain}/ddos/rules/{id}": {
    /** Get DDoS protection's rule information */
    get: operations["ddos.rules.show"];
    /** Delete DDoS protection rule */
    delete: operations["ddos.rules.destroy"];
    /** Update the DDoS protection rule */
    patch: operations["ddos.rules.update"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        id: components["parameters"]["Id"];
      };
    };
  };
  "/domains/{domain}/ddos/actions/reprioritize": {
    /**
     * Change priority of ddos rules
     * @description You can choose a DDoS rule and request to put it after or before another rule.
     * You should only provide either after_rule_id or before_rule_id (and not both of them).
     */
    post: operations["ddos.reprioritize"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
  };
  "/domains/{domain}/rate-limit/settings": {
    /** Get Rate limiting settings */
    get: operations["rate-limiting.settings.index"];
    /** Update domain's Rate limiting configuration */
    patch: operations["rate-limiting.settings.update"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
  };
  "/domains/{domain}/rate-limit/rules": {
    /** Get Rate limiting rules */
    get: operations["rate-limiting.rules.index"];
    /** Store new Rate limiting rule */
    post: operations["rate-limiting.rules.store"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
  };
  "/domains/{domain}/rate-limit/rules/{id}": {
    /** Get Rate limiting's rule information */
    get: operations["rate-limiting.rules.show"];
    /** Delete Rate limiting's rule */
    delete: operations["rate-limiting.rules.destroy"];
    /** Update the Rate limiting's rule */
    patch: operations["rate-limiting.rules.update"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        id: components["parameters"]["Id"];
      };
    };
  };
  "/domains/{domain}/rate-limit/actions/reprioritize": {
    /**
     * Change priority of Rate limiting's rules
     * @description You can choose a rule and request to put it after or before another rule.
     * You should only provide either after_rule_id or before_rule_id (and not both of them).
     */
    post: operations["rate-limiting.actions.reprioritize"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
  };
  "/apps": {
    /** Get list of all available cdn-apps */
    get: operations["apps.index"];
  };
  "/apps/{id}": {
    /** Get a single cdn-app */
    get: operations["apps.show"];
    /** Expressing like and dislike about a single cdn-app */
    post: operations["apps.like"];
    parameters: {
      path: {
        id: components["parameters"]["Id"];
      };
    };
  };
  "/domains/{domain}/apps": {
    /** Get list of all applications installed on a domain */
    get: operations["domains.apps.index"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
  };
  "/domains/{domain}/apps/{id}": {
    /** Check the application is installed on the domain */
    get: operations["domains.apps.installed"];
    /** Install the application on the domain */
    post: operations["domains.apps.store"];
    /** Uninstall the application from domain */
    delete: operations["domains.apps.destroy"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        id: components["parameters"]["Id"];
      };
    };
  };
  "/domains/{domain}/apps/{id}/actions/trigger_webhook": {
    /** trigger webhook event */
    post: operations["domains.apps.trigger-webhook"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        id: components["parameters"]["Id"];
      };
    };
  };
  "/apps/category": {
    /** Get the list of application categories */
    get: operations["apps.category.index"];
  };
  "/apps/category/{application-category}": {
    /** Get an existing application category */
    get: operations["apps.category.show"];
  };
  "/domains/{domain}/ssl": {
    /** Get SSL settings */
    get: operations["ssl.index"];
    /** Update domain's SSL settings */
    patch: operations["ssl.update"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
  };
  "/domains/{domain}/ssl/certificates": {
    /** Upload Certificate */
    post: operations["ssl.cert.store"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
  };
  "/domains/{domain}/ssl/certificates/{id}": {
    /** Delete an unused customer certificate */
    delete: operations["ssl.cert.destroy"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        id: components["parameters"]["Id"];
      };
    };
  };
  "/domains/{domain}/ssl/orders": {
    /** Get All Managed certificate orders history */
    get: operations["ssl.cert.order.index"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
  };
  "/domains/{domain}/ssl/orders/action/retry": {
    /** Retry a previously `killed` order */
    post: operations["ssl.cert.order.retry"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
  };
  "/domains/{domain}/health-checks": {
    /** Get Defined HealthCheck */
    get: operations["active-health-check.index"];
    /** Store a new HealthCheck */
    post: operations["active-health-check.store"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
  };
  "/domains/{domain}/health-checks/{healthcheck}": {
    /** Get a single healthcheck */
    get: operations["active-health-check.show"];
    /** Delete healthcheck */
    delete: operations["active-health-check.destroy"];
    /** Update Health check */
    patch: operations["active-health-check.update"];
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        healthcheck: components["parameters"]["HealthCheck"];
      };
    };
  };
  "/domains/{domain}/health-checks/reports/summary": {
    /** Get summary reports of a single healthcheck monitoring */
    get: operations["active-health-check.reports.summary"];
    parameters: {
      query: {
        name: components["parameters"]["HealthCheckName"];
        upstream: components["parameters"]["HealthCheckUpstream"];
        period?: components["parameters"]["ReportPeriod"];
        since?: components["parameters"]["ReportSince"];
        until?: components["parameters"]["ReportUntil"];
        direction?: components["parameters"]["Direction"];
      };
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
  };
  "/domains/{domain}/health-checks/reports/details": {
    /** Get reports of a single healthcheck monitoring */
    get: operations["active-health-check.reports.details"];
    parameters: {
      query: {
        name: components["parameters"]["HealthCheckName"];
        upstream: components["parameters"]["HealthCheckUpstream"];
        type?: components["parameters"]["HealthCheckReportType"];
        period?: components["parameters"]["ReportPeriod"];
        since?: components["parameters"]["ReportSince"];
        until?: components["parameters"]["ReportUntil"];
        direction?: components["parameters"]["Direction"];
        per_page?: components["parameters"]["PerPage"];
        page?: components["parameters"]["Page"];
      };
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
  };
  "/health-checks/zones": {
    /** Get list of all health-check zones */
    get: operations["health-checks.zones.index"];
  };
  "/dynamic-fields": {
    /** Get the list of Lists */
    get: operations["lists.index"];
    /** Store new List */
    post: operations["lists.store"];
  };
  "/dynamic-fields/{id}": {
    /** Get an existing List */
    get: operations["lists.show"];
    /** Delete List */
    delete: operations["lists.destroy"];
    /** Update an existing List */
    patch: operations["lists.update"];
    parameters: {
      path: {
        id: components["parameters"]["Id"];
      };
    };
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    SavedTrafficsCharts: {
      request?: ({
          /** @enum {string} */
          name?: "reports.request.hit" | "reports.request.miss";
          y?: number;
        })[];
      traffic?: ({
          /** @enum {string} */
          name?: "reports.traffic.hit" | "reports.traffic.miss";
          y?: number;
        })[];
    };
    SavedTrafficsStatistics: {
      traffic?: {
        saved?: number;
        total?: number;
      };
      request?: {
        saved?: number;
        total?: number;
      };
    };
    SavedTrafficsData: {
      data?: {
        statistics?: components["schemas"]["SavedTrafficsStatistics"];
        charts?: components["schemas"]["SavedTrafficsCharts"];
      };
    } & components["schemas"]["DataResponse"];
    TransportLayerProxyTrafficCharts: {
      traffics?: {
        /** @enum {string} */
        title?: "reports.traffics";
        categories?: string[];
        series?: ({
            /** @enum {string} */
            name?: "reports.traffics.bytes_out" | "reports.traffics.bytes_in" | "reports.traffics.connections";
            data?: number[];
          })[];
      };
    };
    TrafficCharts: {
      requests?: {
        /** @enum {string} */
        title?: "reports.requests";
        categories?: string[];
        series?: ({
            /** @enum {string} */
            name?: "reports.requests.total" | "reports.requests.saved";
            data?: number[];
          })[];
      };
      traffics?: {
        /** @enum {string} */
        title?: "reports.traffics";
        categories?: string[];
        series?: ({
            /** @enum {string} */
            name?: "reports.traffics.total" | "reports.traffics.saved";
            data?: number[];
          })[];
      };
    };
    TrafficStatistics: {
      traffics?: {
        saved: number;
        bypass?: number;
        /** Format: date-time */
        top: string;
        total: number;
      };
      requests?: {
        saved: number;
        bypass?: number;
        /** Format: date-time */
        top: string;
        total: number;
      };
    };
    TransportLayerProxyTrafficsData: {
      data?: {
        charts?: components["schemas"]["TransportLayerProxyTrafficCharts"];
      };
    } & components["schemas"]["DataResponse"];
    TrafficsData: {
      data?: components["schemas"]["Traffics"];
    } & components["schemas"]["DataResponse"];
    CountryStatistics: {
      /** @description The name of the country */
      country?: string;
      /** @description The number of requests from the country */
      requests?: number;
      /** @description The amount of traffic from the country */
      traffics?: number;
    };
    /**
     * @example {
     *   "IRN": {
     *     "fillKey": 4,
     *     "name": "Iran (Islamic Republic of)",
     *     "value": 12456789
     *   },
     *   "description": "A dictionay which maps country codes to fill and value"
     * }
     */
    CountryRequestChart: {
      /** @description The fill key for the country */
      fillKey?: number;
      /** @description The name of the country */
      name?: string;
      /** @description The number of requests from the country */
      value?: number;
    };
    CountryTrafficChart: {
      /** @description The fill key for the country */
      fillKey?: number;
      /** @description The name of the country */
      name?: string;
      /** @description The amount of traffic from the country */
      value?: number;
    };
    CountryList: {
      /** @description The name of the country */
      country?: string;
      /** @description The 2-letter country code */
      code?: string;
      /** @description The number of requests from the country */
      requests?: number;
      /** @description The amount of traffic from the country */
      traffics?: number;
    };
    MapTrafficsData: {
      data?: components["schemas"]["TrafficsMap"];
    } & components["schemas"]["DataResponse"];
    VisitorsStatistics: {
      visitors?: {
        /** Format: date-time */
        top_visitors: string;
        total_visitors: number;
      };
    };
    VisitorsCharts: {
      visitors?: {
        /** @enum {string} */
        title?: "reports.visitor";
        categories?: string[];
        series?: {
            /** @enum {string} */
            name?: "reports.visitor.visitors";
            data?: number[];
          }[];
      };
    };
    Traffics: {
      statistics?: components["schemas"]["TrafficStatistics"];
      charts?: components["schemas"]["TrafficCharts"];
    };
    TrafficsMap: {
      /** @deprecated */
      statistics?: components["schemas"]["CountryStatistics"][];
      charts?: {
        requests?: {
          [key: string]: components["schemas"]["CountryRequestChart"];
        };
        traffics?: {
          [key: string]: components["schemas"]["CountryTrafficChart"];
        };
      };
      lists?: components["schemas"]["CountryList"][];
    };
    Visitors: {
      statistics?: components["schemas"]["VisitorsStatistics"];
      charts?: components["schemas"]["VisitorsCharts"];
    };
    VisitorsData: {
      data?: components["schemas"]["Visitors"];
    } & components["schemas"]["DataResponse"];
    HighRequestedIp: {
      ip?: string;
      request_count?: number;
    };
    ResponseTime: {
      statistics?: {
        response_time?: Record<string, unknown> | null;
      };
      charts?: {
        ir?: {
          /** @enum {string} */
          title?: "reports.response_time";
          categories?: string[];
          series?: {
              /** @enum {string} */
              name?: "reports.response_time.Server";
              data?: number[];
            }[];
        };
      };
    };
    ResponseTimeData: {
      data?: components["schemas"]["ResponseTime"];
    } & components["schemas"]["DataResponse"];
    StatusCodeReport: {
      statistics?: {
        status_codes?: {
          "2xx_sum"?: number;
          "3xx_sum"?: number;
          "4xx_sum"?: number;
          "5xx_sum"?: number;
        };
      };
      charts?: {
        status_code?: {
          /** @enum {string} */
          name?: "status_code";
          categories?: string[];
          series?: ({
              /** @enum {string} */
              name?: "report.status_code.2xx" | "report.status_code.3xx" | "report.status_code.4xx";
              data?: number[];
            })[];
        };
      };
    };
    StatusCodeReportData: {
      data?: components["schemas"]["StatusCodeReport"];
    } & components["schemas"]["DataResponse"];
    StatusCodeSummary: {
      /** @deprecated */
      statistics?: Record<string, never>;
      charts?: {
        status_code?: {
            name?: string;
            y?: number;
          }[];
      };
    };
    StatusCodeSummaryData: {
      data?: components["schemas"]["StatusCodeSummary"];
    } & components["schemas"]["DataResponse"];
    ErrorLog: {
      /** @description The error message */
      name?: string;
      /** @description The error's count */
      count?: number;
      upstreams?: {
          /** @description The upstream's address */
          address?: string;
          /** @description Error count per upstream */
          count?: number;
        }[];
    };
    ErrorLogsData: {
      data?: components["schemas"]["ErrorLog"][];
    } & components["schemas"]["DataResponse"];
    ErrorLogChart: {
      statistics?: {
        /** @description <key, value> where key is error and value is its count */
        status_codes?: {
          [key: string]: unknown;
        };
      };
      charts?: {
        status_code?: {
          /** @enum {string} */
          title?: "reports.status_code";
          categories?: string[];
          series?: {
              /** @description The error message */
              name?: string;
              data?: number[];
            }[];
        };
      };
    };
    ErrorLogChartData: {
      data?: components["schemas"]["ErrorLogChart"];
    } & components["schemas"]["DataResponse"];
    DnsRequestReport: {
      statistics?: {
        total?: number;
        /** Format: date-time */
        top?: string;
      };
      charts?: {
        requests?: {
          /** @enum {string} */
          title?: "reports.requests";
          categories?: string[];
          series?: {
              /** @enum {string} */
              name?: "reports.requests.request";
              data?: number[];
            }[];
        };
      };
    };
    DnsRequestReportData: {
      data?: components["schemas"]["DnsRequestReport"];
    } & components["schemas"]["DataResponse"];
    DnsGeoReport: {
      /** @deprecated */
      statistics?: unknown[];
      charts?: {
        /**
         * @description A dictionay which maps country codes to fill and value
         * @example {
         *   "IRN": {
         *     "fillKey": 4,
         *     "name": "Iran (Islamic Republic of)",
         *     "value": 12456789
         *   }
         * }
         */
        requests?: {
          [key: string]: {
            fillKey?: number;
            name?: string;
            value?: number;
          };
        };
      };
      lists?: {
          country?: string;
          name?: string;
          code?: string;
          requests?: number;
        }[];
    };
    DnsGeoReportData: {
      data?: components["schemas"]["DnsGeoReport"];
    } & components["schemas"]["DataResponse"];
    AttackReport: {
      statistics?: {
        attacks?: {
          total?: number;
          /** Format: date-time */
          top?: string;
        };
      };
      charts?: {
        attacks?: {
          /** @enum {string} */
          title?: "reports.attack";
          categories?: string[];
          series?: {
              /** @enum {string} */
              name?: "reports.attack.attacks";
              data?: number[];
            }[];
        };
      };
    };
    AttackReportItem: {
      /** Format: ipv4 */
      attacker_ip?: string;
      attacker_country?: string;
      /** @enum {string} */
      method?: "GET" | "POST" | "PUT" | "PATCH" | "DELETE" | "HEAD" | "OPTION";
      /** Format: uri */
      uri?: string;
      host?: string[];
      /** Format: date-time */
      timestamp?: string;
      uri_args?: string;
      cookie?: string;
      alerts?: string[];
      user_agent?: string[];
    };
    AttackReportMap: {
      /** @deprecated */
      statistics?: {
          /** @description The 2-letter country code */
          country?: string;
          /** @description The name of the country */
          name?: string;
          /** @description The 3-letter country code */
          code?: string;
          /** @description The number of attacks */
          attack?: number;
        }[];
      charts?: {
        attacks?: {
          [key: string]: {
            /** @description A numerical key used for coloring the map */
            fillKey?: number;
            /** @description The name of the country */
            name?: string;
            /** @description The number of attacks */
            value?: number;
          };
        };
      };
      lists?: {
          /** @description The 2-letter country code */
          country?: string;
          /** @description The name of the country */
          name?: string;
          /** @description The 3-letter country code */
          code?: string;
          /** @description The number of attacks */
          attack?: number;
        }[];
    };
    AttackReportMapData: {
      data?: components["schemas"]["AttackReportMap"];
    } & components["schemas"]["DataResponse"];
    AttackReportUri: {
      /** Format: uri */
      uri?: string;
      count?: number;
    };
    AttackReportUriData: {
      data?: components["schemas"]["AttackReportUri"][];
    } & components["schemas"]["DataResponse"];
    BulkTrafficReport: {
      /**
       * Format: uuid
       * @description Domain's ID
       */
      resource?: string;
      success?: boolean;
      /** @description The error message */
      message?: string | null;
      data?: {
        requests?: number;
        ingress_bytes?: number;
        egress_bytes?: {
          iran?: number;
          europe_americas?: number;
          others?: number;
        };
      };
    };
    BulkTrafficReportData: {
      data?: components["schemas"]["BulkTrafficReport"][];
    } & components["schemas"]["DataResponse"];
    BulkVisitorReport: {
      /**
       * Format: uuid
       * @description Domain's ID
       */
      resource?: string;
      success?: boolean;
      /** @description The error message */
      message?: string | null;
      data?: {
        visitors?: number;
      };
    };
    BulkVisitorReportData: {
      data?: components["schemas"]["BulkVisitorReport"][];
    } & components["schemas"]["DataResponse"];
    EmailForwardingStats: {
      /** Format: uuid */
      id?: string;
      dns_activation?: boolean;
      recipients_count?: number;
      aliases_count?: number;
      is_active?: boolean;
      is_configured?: boolean;
      emails_forwarded?: number;
      emails_blocked?: number;
      emails_replied?: number;
    };
    EmailForwardingStatsData: {
      data?: components["schemas"]["EmailForwardingStats"];
    } & components["schemas"]["DataResponse"];
    EmailForwardingRecipientsList: {
        id?: string;
        /** Format: email */
        email?: string;
        is_verified?: boolean;
        is_default?: boolean;
      }[];
    EmailForwardingRecipientsListData: {
      data?: components["schemas"]["EmailForwardingRecipientsList"];
    } & components["schemas"]["DataResponse"];
    EmailForwardingRecipientsStore: {
      /** Format: email */
      email: string;
    };
    EmailForwardingRecipient: {
      id?: string;
      /** Format: email */
      email?: string;
      is_verified?: boolean;
      is_default?: boolean;
    };
    EmailForwardingRecipientsVerify: {
      code: string;
    };
    EmailForwardingAliasesList: {
        /** Format: uuid */
        id?: string;
        local_part?: string;
        /** Format: email */
        email?: string;
        is_active?: boolean;
      }[];
    EmailForwardingAliasesListData: {
      data?: components["schemas"]["EmailForwardingAliasesList"];
    } & components["schemas"]["DataResponse"];
    EmailForwardingAliasesStore: {
      local_part: string;
      recipients: string[];
    };
    EmailForwardingAlias: {
      /** Format: uuid */
      id?: string;
      local_part?: string;
      /** Format: email */
      email?: string;
      is_active?: boolean;
    };
    EmailForwardingAliasesToggleActivation: {
      is_active: boolean;
    };
    EmailForwardingAliasesRecipients: {
      recipients: string[];
    };
    DataWithMessageResponse: {
      message?: string | null;
      data?: Record<string, unknown> | null;
    };
    DataResponse: {
      data?: Record<string, unknown> | null;
    };
    PaginatedResponse: {
      data?: Record<string, never>[];
      links?: components["schemas"]["PaginatedResponseLinks"];
      meta?: components["schemas"]["PaginatedResponseMeta"];
    };
    PaginatedResponseMeta: {
      current_page?: number;
      from?: number;
      last_page?: number;
      /** Format: url */
      path?: string;
      per_page?: number;
      to?: number;
      total?: number;
    };
    PaginatedResponseLinks: {
      /** Format: url */
      first: string;
      /** Format: url */
      last?: string | null;
      /** Format: url */
      prev: string | null;
      /** Format: url */
      next: string | null;
    };
    CustomCname: {
      /** Format: hostname */
      address: string;
    };
    readonly DomainTransferData: {
      /** Format: hostname */
      readonly domain?: string;
      /** Format: uuid */
      readonly account_id?: string;
      readonly account_name?: string;
      readonly owner_name?: string;
      /** Format: uuid */
      readonly owner_id?: string;
      /** Format: date-time */
      readonly time?: string;
      readonly incoming?: boolean;
    };
    Domain: {
      /** Format: uuid */
      id?: string;
      /** Format: uuid */
      user_id?: string;
      /**
       * Format: hostname
       * @deprecated
       * @description Deprecated in favor of name attribute
       */
      domain?: string;
      /** Format: hostname */
      name?: string;
      plan_level?: components["schemas"]["Plan"];
      /** @description Desired NS values for the domain */
      ns_keys?: string[];
      /** @description Current NS values for the domain */
      current_ns?: string[];
      /**
       * Format: hostname
       * @description Current record for CNAME Setup of the domain
       */
      target_cname?: string | null;
      /**
       * Format: hostname
       * @description Domain's custom record for CNAME Setup
       */
      custom_cname?: string | null;
      /**
       * @description Partial domain is using CNAME Setup and full domain is using NS Setup
       * @enum {string}
       */
      type?: "full" | "partial";
      /** @enum {string} */
      status?: "initializing" | "pending" | "active" | "moved";
      /** @default false */
      dns_cloud?: boolean;
      restriction?: ("paused" | "suspended" | "unfair" | "charged")[];
      transfer?: components["schemas"]["DomainTransferData"];
      /** @default false */
      fingerprint_status?: boolean;
      /** Format: date-time */
      created_at?: string;
      /** Format: date-time */
      updated_at?: string;
    };
    DomainStore: {
      /**
       * Format: hostname
       * @description Name of the domain
       */
      domain: string;
      /**
       * @description If you want to register a subdomain, you can use cname setup by sending partial type
       * @default full
       * @enum {string}
       */
      domain_type?: "full" | "partial";
      plan_level?: components["schemas"]["Plan"];
    };
    DomainResponse: {
      data?: components["schemas"]["Domain"];
    } & components["schemas"]["DataWithMessageResponse"];
    TransferDomain: {
      /** Format: uuid */
      account_id: string;
    };
    TransferDomainChangeStatus: {
      /**
       * Format: hostname
       * @example example.com
       */
      domain: string;
      /** @enum {string} */
      status: "accept" | "cancel";
      /** @default false */
      preserve_state?: boolean;
    };
    NsKeys: {
      /** @description Desired NS values for the domain */
      ns_keys?: string[];
    };
    NsKeysResponse: {
      data?: {
        /** @description Desired NS values for the domain */
        ns_keys?: string[];
      };
    } & components["schemas"]["DataWithMessageResponse"];
    NsDomain: {
      /** @description Current NS records of the domain */
      ns_domain?: string[];
      /** @description Desired NS values for the domain */
      ns_keys?: string[];
    };
    DeprecatedNs: {
      /** @description Current NS records of the domain */
      ns_domain?: string[];
      /** @description Desired NS values for the domain */
      ns_keys?: string[];
      ns_status?: boolean;
    };
    /**
     * @description - `0` - Traffic
     * - `1` - Basic
     * - `2` - Growth
     * - `3` - Professional
     * - `4` - Enterprise
     * - Subdomains require to have Growth plan or higher
     */
    Plan: number;
    PlanUpdate: {
      plan_level: components["schemas"]["Plan"];
    };
    "A-RecordValue": {
      /** Format: ipv4 */
      ip: string;
      port?: number | null;
      weight?: number | null;
      /**
       * @description This key shows itself here if the weight have been changed by Health Check.
       * @example 100
       */
      original_weight?: number;
      /**
       * @description ISO 3166 alpha-2 country code
       * @example US
       */
      country?: string | null;
    };
    "A-RecordValues": components["schemas"]["A-RecordValue"][];
    "AAAA-RecordValues": components["schemas"]["AAAA-RecordValue"][];
    "AAAA-RecordValue": {
      /** Format: ipv6 */
      ip: string;
      port?: number | null;
      weight?: number | null;
      /**
       * @description This key shows itself here if the weights have been changed by Health Check.
       * @example 100
       */
      original_weight?: number;
      /**
       * @description ISO 3166 alpha-2 country code
       * @example US
       */
      country?: string | null;
    };
    "MX-RecordValue": {
      host: components["schemas"]["HostName"];
      priority: number | null;
    };
    "NS-RecordValue": {
      host: components["schemas"]["HostName"];
    };
    "SRV-RecordValue": {
      target: components["schemas"]["HostName"];
      port: number | null;
      weight?: number | null;
      priority?: number | null;
    };
    "TXT-RecordValue": {
      text: string;
    };
    "SPF-RecordValue": components["schemas"]["TXT-RecordValue"];
    "DKIM-RecordValue": components["schemas"]["TXT-RecordValue"];
    "ANAME-RecordValue": {
      location: components["schemas"]["Fqdn"];
      /** @enum {string|null} */
      host_header: "source" | "dest" | null;
      port?: number | null;
    };
    "CNAME-RecordValue": {
      host: components["schemas"]["Fqdn"];
      /** @enum {string|null} */
      host_header: "source" | "dest" | null;
      port?: number | null;
    };
    "PTR-RecordValue": {
      domain?: components["schemas"]["HostName"];
    };
    "TLSA-RecordValue": {
      usage: string;
      selector: string;
      matching_type: string;
      /** @example 1SKJND4KSID7OS9KJ21LSJ */
      certificate: string;
    };
    "CAA-RecordValue": {
      /**
       * @description Should be a valid domain
       * @example example.com
       */
      value: string;
      /** @enum {string} */
      tag: "issuewild" | "issue" | "iodef";
    };
    /**
     * Format: hostname
     * @description A fully-qualified domain name (FQDN)
     * @example cdn.example.com
     */
    Fqdn: string;
    /**
     * Format: hostname
     * @example cdn.example.com
     */
    HostName: string;
    DnsRecord: components["schemas"]["A-Record"] | components["schemas"]["AAAA-Record"] | components["schemas"]["NS-Record"] | components["schemas"]["TXT-Record"] | components["schemas"]["CNAME-Record"] | components["schemas"]["ANAME-Record"] | components["schemas"]["MX-Record"] | components["schemas"]["SRV-Record"] | components["schemas"]["SPF-Record"] | components["schemas"]["DKIM-Record"] | components["schemas"]["PTR-Record"] | components["schemas"]["TLSA-Record"] | components["schemas"]["CAA-Record"];
    DnsRecordGeneric: components["schemas"]["DnsRecordGenericArrayValue"] | components["schemas"]["DnsRecordGenericObjectValue"];
    DnsRecordGenericObjectValue: {
      /**
       * @example {
       *   "text": "example"
       * }
       */
      value?: Record<string, never>;
      /** @example cname */
      type?: string;
    } & components["schemas"]["BaseDnsRecord"];
    DnsRecordGenericArrayValue: {
      /**
       * @example [
       *   {
       *     "ip": "198.51.100.42",
       *     "port": 65535,
       *     "weight": 1000,
       *     "country": "US"
       *   }
       * ]
       */
      value?: unknown[];
      /** @example a */
      type?: string;
    } & components["schemas"]["BaseDnsRecord"];
    "CAA-Record": {
      value?: components["schemas"]["CAA-RecordValue"];
      /**
       * @default caa
       * @enum {string}
       */
      type?: "caa";
    } & components["schemas"]["BaseDnsRecord"];
    "TLSA-Record": {
      value?: components["schemas"]["TLSA-RecordValue"];
      /**
       * @default tlsa
       * @enum {string}
       */
      type?: "tlsa";
    } & components["schemas"]["BaseDnsRecord"];
    "PTR-Record": {
      value?: components["schemas"]["PTR-RecordValue"];
      /**
       * @default ptr
       * @enum {string}
       */
      type?: "ptr";
    } & components["schemas"]["BaseDnsRecord"];
    "DKIM-Record": {
      value?: components["schemas"]["DKIM-RecordValue"];
      /**
       * @default dkim
       * @enum {string}
       */
      type?: "dkim";
    } & components["schemas"]["BaseDnsRecord"];
    "SPF-Record": {
      value?: components["schemas"]["SPF-RecordValue"];
      /**
       * @default spf
       * @enum {string}
       */
      type?: "spf";
    } & components["schemas"]["BaseDnsRecord"];
    "SRV-Record": {
      value?: components["schemas"]["SRV-RecordValue"];
      /**
       * @default srv
       * @enum {string}
       */
      type?: "srv";
    } & components["schemas"]["BaseDnsRecord"];
    "TXT-Record": {
      value?: components["schemas"]["TXT-RecordValue"];
      /**
       * @default txt
       * @enum {string}
       */
      type?: "txt";
    } & components["schemas"]["BaseDnsRecord"];
    "MX-Record": {
      value?: components["schemas"]["MX-RecordValue"];
      /**
       * @default mx
       * @enum {string}
       */
      type?: "mx";
    } & components["schemas"]["BaseDnsRecord"];
    "ANAME-Record": {
      value?: components["schemas"]["ANAME-RecordValue"];
      /**
       * @default aname
       * @enum {string}
       */
      type?: "aname";
    } & components["schemas"]["BaseDnsRecord"];
    "CNAME-Record": {
      value?: components["schemas"]["CNAME-RecordValue"];
      /**
       * @default cname
       * @enum {string}
       */
      type?: "cname";
    } & components["schemas"]["BaseDnsRecord"];
    "NS-Record": {
      value?: components["schemas"]["NS-RecordValue"];
      /**
       * @default ns
       * @enum {string}
       */
      type?: "ns";
    } & components["schemas"]["BaseDnsRecord"];
    "A-Record": {
      value?: components["schemas"]["A-RecordValues"];
      /**
       * @default a
       * @enum {string}
       */
      type?: "a";
    } & components["schemas"]["BaseDnsRecord"];
    "AAAA-Record": {
      value?: components["schemas"]["AAAA-RecordValues"];
      /**
       * @default aaaa
       * @enum {string}
       */
      type?: "aaaa";
    } & components["schemas"]["BaseDnsRecord"];
    BaseDnsRecord: {
      /** Format: uuid */
      id?: string;
      name?: string;
      /** @enum {integer} */
      ttl?: 120 | 180 | 300 | 600 | 900 | 1800 | 3600 | 7200 | 18000 | 43200 | 86400 | 172800 | 432000;
      /** @default false */
      cloud?: boolean;
      /** @enum {string} */
      upstream_https?: "default" | "auto" | "http" | "https";
      ip_filter_mode?: components["schemas"]["DnsRecordIpFilterMode"];
      /**
       * @description Protected records cannot be modified or deleted by user.
       * @default false
       */
      is_protected?: boolean;
      /** @default [] */
      usage?: readonly ("transport-layer-proxy" | "certificate-issuance")[];
      /** Format: date-time */
      created_at?: string;
      /** Format: date-time */
      updated_at?: string;
    };
    DnsRecordIpFilterMode: {
      /** @enum {string} */
      count?: "single" | "multi";
      /** @enum {string} */
      order?: "none" | "weighted" | "rr";
      /** @enum {string} */
      geo_filter?: "none" | "location" | "country";
    };
    DnsRecordResponse: {
      data?: components["schemas"]["DnsRecordGeneric"];
    } & components["schemas"]["DataWithMessageResponse"];
    DnsRecordData: {
      data?: components["schemas"]["DnsRecordGeneric"];
    } & components["schemas"]["DataResponse"];
    DnsRecordCloud: {
      cloud: boolean;
    };
    DnsRecordImport: {
      /** Format: binary */
      f_zone_file?: string;
    };
    DnsSec: {
      /** @default false */
      enabled?: boolean;
      ds?: string | null;
    };
    DnsSecData: {
      data?: components["schemas"]["DnsSec"];
    } & components["schemas"]["DataResponse"];
    DnsSecStatus: {
      enable: boolean;
    };
    PageRuleSummary: {
      /** Format: uuid */
      id?: string;
      /** Format: uuid */
      domain_id?: string;
      /** @description Order of the page-rule */
      seq?: number;
      /**
       * @deprecated
       * @description This flag is deprecated in favor of is_protected flag
       * @default default
       * @enum {string}
       */
      url_type?: "default" | "index" | "directory" | "extension" | "page" | "regex";
      /**
       * @description Protected records cannot be modified or deleted by user.
       * @default false
       */
      is_protected?: boolean;
      /** @description URL pattern of target pages */
      url?: string;
      /**
       * @default query_string
       * @enum {string}
       */
      cache_level?: "off" | "uri" | "query_string";
      /** @default true */
      waf_status?: boolean;
      /**
       * @deprecated
       * @description Shows whether firewall is enabled or not
       * @default true
       */
      fw_status?: boolean;
      acceleration?: components["schemas"]["Acceleration"];
      /**
       * @description Secure link is enabled or not
       * @default false
       */
      slink_status?: boolean;
      /**
       * @description Is the page-rule enabled?
       * @default true
       */
      status?: boolean;
      /** Format: date-time */
      created_at?: string;
      /** Format: date-time */
      updated_at?: string;
    };
    PageRule: ({
      /**
       * @default 30m
       * @enum {string}
       */
      cache_200?: "0s" | "1s" | "2s" | "3s" | "4s" | "5s" | "6s" | "7s" | "8s" | "9s" | "10s" | "30s" | "1m" | "3m" | "5m" | "10m" | "30m" | "45m" | "1h" | "3h" | "5h" | "10h" | "12h" | "24h" | "3d" | "7d" | "10d" | "15d" | "30d";
      /**
       * @default 0s
       * @enum {string}
       */
      cache_any?: "0s" | "1s" | "2s" | "3s" | "4s" | "5s" | "6s" | "7s" | "8s" | "9s" | "10s" | "30s" | "1m" | "3m" | "5m" | "10m" | "30m" | "45m" | "1h" | "3h" | "5h" | "10h" | "12h" | "24h" | "3d" | "7d" | "10d" | "15d" | "30d";
      /**
       * @description Cookie variables to consider in cache (comma separaterd values)
       * @default
       */
      cache_cookie?: string;
      /** @default false */
      cache_device_type?: boolean;
      /** @default true */
      cache_args?: boolean;
      /**
       * @description Query string arguments to consider in cache (& seperated values)
       * @default
       * @example filter&sort
       */
      cache_arg?: string;
      /**
       * @deprecated
       * @default true
       */
      cache_scheme?: boolean;
      /**
       * @default default
       * @enum {string}
       */
      cache_browser?: "default" | "0s" | "1s" | "2s" | "3s" | "4s" | "5s" | "6s" | "7s" | "8s" | "9s" | "10s" | "30s" | "1m" | "3m" | "5m" | "10m" | "30m" | "45m" | "1h" | "3h" | "5h" | "10h" | "12h" | "24h" | "3d" | "7d" | "10d" | "15d" | "30d";
      /**
       * @description Ignore default behavior in caching set-cookie header
       * @default false
       */
      cache_ignore_sc?: boolean;
      /**
       * @description Ignore default behavior in caching vary header
       * @default true
       */
      cache_ignore_vary?: boolean;
      /** @default true */
      cache_ignore_cc?: boolean;
      /** @default - */
      cors_header?: string;
      /** @default - */
      rewrite_url?: string;
      /** @default */
      slink_secret?: string;
      /**
       * @default [
       *   "remote_addr",
       *   "file",
       *   "expires"
       * ]
       */
      slink_md5?: (("remote_addr" | "file" | "expires" | "url" | "uri")[]) | null;
      /**
       * @description Name or ID of the load balancer
       * @default null
       */
      load_balancer?: string | null;
      /**
       * @deprecated
       * @default false
       */
      cluster_status?: boolean;
      image_resize?: components["schemas"]["PageRuleImageResize"];
      /**
       * Format: uuid
       * @deprecated
       * @default null
       */
      cluster_id?: string | null;
      upstream_timeout?: components["schemas"]["UpstreamTimeout"];
      /** @default [] */
      req_custom_headers?: {
          name?: string;
          value?: string;
        }[];
      /** @default [] */
      res_custom_headers?: {
          name?: string;
          value?: string;
        }[];
      /** @default [] */
      req_hide_headers?: string[];
      /** @default [] */
      res_hide_headers?: string[];
      /**
       * Format: hostname
       * @default
       */
      custom_host_header?: string;
      redirect?: components["schemas"]["PageRuleRedirect"];
    }) & components["schemas"]["PageRuleSummary"];
    UpstreamTimeout: {
      /**
       * @description Seconds to timeout
       * @default 30
       */
      connect_timeout?: number;
      /**
       * @description Seconds to timeout
       * @default 100
       */
      read_timeout?: number;
      /**
       * @description Seconds to timeout
       * @default 300
       */
      send_timeout?: number;
    };
    PageRuleRedirect: {
      /** @default false */
      enable?: boolean;
      /**
       * @default 301
       * @enum {integer}
       */
      status_code?: 301 | 302 | 307;
      /** Format: url */
      url?: string | null;
    };
    PageRuleResponse: {
      data?: components["schemas"]["PageRule"];
    } & components["schemas"]["DataWithMessageResponse"];
    PageRuleData: {
      data?: components["schemas"]["PageRule"];
    } & components["schemas"]["DataResponse"];
    PageRuleDiff: {
      /** @description URL pattern of target pages */
      url?: string;
      /** @enum {string} */
      cache_level?: "off" | "uri" | "query_string";
      waf_status?: boolean;
      /**
       * @deprecated
       * @description Shows whether firewall is enabled or not
       */
      fw_status?: boolean;
      acceleration?: components["schemas"]["Acceleration"];
      /** @description Secure link is enabled or not */
      slink_status?: boolean;
      /** @description Is the page-rule enabled? */
      status?: boolean;
      /** @enum {string} */
      cache_200?: "0s" | "1s" | "2s" | "3s" | "4s" | "5s" | "6s" | "7s" | "8s" | "9s" | "10s" | "30s" | "1m" | "3m" | "5m" | "10m" | "30m" | "45m" | "1h" | "3h" | "5h" | "10h" | "12h" | "24h" | "3d" | "7d" | "10d" | "15d" | "30d";
      /** @enum {string} */
      cache_any?: "0s" | "1s" | "2s" | "3s" | "4s" | "5s" | "6s" | "7s" | "8s" | "9s" | "10s" | "30s" | "1m" | "3m" | "5m" | "10m" | "30m" | "45m" | "1h" | "3h" | "5h" | "10h" | "12h" | "24h" | "3d" | "7d" | "10d" | "15d" | "30d";
      /** @description Cookie variables to consider in cache (comma separaterd values) */
      cache_cookie?: string;
      cache_args?: boolean;
      /**
       * @description Query string arguments to consider in cache (& seperated values)
       * @default
       * @example filter&sort
       */
      cache_arg?: string;
      /** @deprecated */
      cache_scheme?: boolean;
      /** @enum {string} */
      cache_browser?: "default" | "0s" | "1s" | "2s" | "3s" | "4s" | "5s" | "6s" | "7s" | "8s" | "9s" | "10s" | "30s" | "1m" | "3m" | "5m" | "10m" | "30m" | "45m" | "1h" | "3h" | "5h" | "10h" | "12h" | "24h" | "3d" | "7d" | "10d" | "15d" | "30d";
      /** @description Ignore default behavior in caching set-cookie header */
      cache_ignore_sc?: boolean;
      /** @description Ignore default behavior in caching vary header */
      cache_ignore_vary?: boolean;
      cache_ignore_cc?: boolean;
      cors_header?: string;
      rewrite_url?: string;
      slink_secret?: string;
      slink_md5?: (("remote_addr" | "file" | "expires" | "url" | "uri")[]) | null;
      cluster_status?: boolean;
      /** Format: uuid */
      cluster_id?: string | null;
      upstream_timeout?: components["schemas"]["UpstreamTimeout"];
      /** @default [] */
      req_custom_headers?: {
          name?: string;
          value?: string;
          is_var?: boolean;
        }[];
      /** @default [] */
      res_custom_headers?: {
          name?: string;
          value?: string;
          is_var?: boolean;
        }[];
      /** @default [] */
      req_hide_headers?: string[];
      res_hide_headers?: string[];
      /** Format: hostname */
      custom_host_header?: string;
      redirect?: {
        enable?: boolean;
        /** @enum {integer} */
        status_code?: 301 | 302 | 307;
        /** Format: url */
        url?: string | null;
      };
    };
    PageRuleDiffData: {
      data?: components["schemas"]["PageRuleDiff"];
    } & components["schemas"]["DataResponse"];
    LoadBalancerRegion: {
      /** Format: uuid */
      id?: string;
      /** @example LAH */
      region?: string;
      name?: string;
    };
    LoadBalancerSetting: {
      /** @enum {string} */
      method?: "cluster_rr" | "cluster_chash";
      /**
       * @description Try another server when the first one failed if on
       * @default off
       * @enum {string}
       */
      next_upstream_tcp?: "on" | "off";
      next_upstream_tcp_codes?: components["schemas"]["NextUpstreamTcpCodes"];
      /** @enum {string} */
      protocol?: "auto" | "http" | "https";
      /**
       * @default off
       * @enum {string}
       */
      keepalive?: "on" | "off";
      /**
       * @description Zero will disable failing strategy.
       * @default 0
       */
      max_fails?: number;
      /**
       * @description Human friendly time duration.
       * @default 10s
       * @example 45s
       */
      fail_timeout?: string;
    };
    /** @description Status codes from the upstream that trigger a switch to the next upstream */
    NextUpstreamTcpCodes: {
      head?: components["schemas"]["NextUpstreamCodes"];
      get?: components["schemas"]["NextUpstreamCodes"];
      post?: components["schemas"]["NextUpstreamCodes"];
      put?: components["schemas"]["NextUpstreamCodes"];
      delete?: components["schemas"]["NextUpstreamCodes"];
      options?: components["schemas"]["NextUpstreamCodes"];
      patch?: components["schemas"]["NextUpstreamCodes"];
    };
    NextUpstreamCodes: (500 | 502 | 503 | 504 | 403 | 404 | 429)[];
    LoadBalancerSettingsData: {
      data?: components["schemas"]["LoadBalancerSetting"];
    } & components["schemas"]["DataResponse"];
    LoadBalancer: {
      /** Format: uuid */
      id?: string;
      /** @example lb1 */
      name?: string;
      description?: string;
      status?: boolean;
      /** @enum {string} */
      method?: "failover" | "cluster_rr" | "cluster_chash";
      /**
       * @description Human friendly time duration for which a pool will uninterruptedly be selected in cluster_rr strategy, i.e. pools will switch once every time slice.
       * @default 0s
       */
      time_slice?: string;
      pools?: readonly components["schemas"]["LoadBalancerPool"][];
      /** Format: date-time */
      created_at?: string;
      /** Format: date-time */
      updated_at?: string;
    };
    LoadBalancerResponse: {
      data?: components["schemas"]["LoadBalancer"];
    } & components["schemas"]["DataWithMessageResponse"];
    LoadBalancerData: {
      data?: components["schemas"]["LoadBalancer"];
    } & components["schemas"]["DataResponse"];
    LoadBalancerPool: {
      /** Format: uuid */
      id?: string;
      name?: string;
      description?: string;
      status?: boolean;
      /** @description Zero means the default pool */
      priority?: number;
      /** @enum {string} */
      method?: "cluster_rr" | "cluster_chash";
      /**
       * @default off
       * @enum {string}
       */
      keepalive?: "on" | "off";
      /**
       * @description Try another server when the first one failed if on
       * @default off
       * @enum {string}
       */
      next_upstream_tcp?: "on" | "off";
      next_upstream_tcp_codes?: components["schemas"]["NextUpstreamTcpCodes"];
      regions?: components["schemas"]["LoadBalancerRegion"][];
      origins?: readonly components["schemas"]["LoadBalancerOrigin"][];
      monitoring_status?: components["schemas"]["MonitoringStatus"];
      /** Format: date-time */
      created_at?: string;
      /** Format: date-time */
      updated_at?: string;
    };
    LoadBalancerPoolData: {
      data?: components["schemas"]["LoadBalancerPool"];
    } & components["schemas"]["DataResponse"];
    LoadBalancerPoolResponse: {
      data?: components["schemas"]["LoadBalancerPool"];
    } & components["schemas"]["DataWithMessageResponse"];
    LoadBalancerOrigin: {
      /** Format: uuid */
      id?: string;
      name?: string;
      /** @enum {string} */
      health_check_status?: "off" | "healthy" | "unhealthy" | "no-data";
      status?: boolean;
      address?: string;
      port?: number;
      weight?: number;
      /**
       * @default auto
       * @enum {string}
       */
      protocol?: "auto" | "http" | "https";
      host_header?: string;
      /** Format: date-time */
      created_at?: string;
      /** Format: date-time */
      updated_at?: string;
    };
    LoadBalancerOriginData: {
      data?: components["schemas"]["LoadBalancerOrigin"];
    } & components["schemas"]["DataResponse"];
    LoadBalancerOriginResponse: {
      data?: components["schemas"]["LoadBalancerOrigin"];
    } & components["schemas"]["DataWithMessageResponse"];
    LoadBalancerStore: {
      /** @example lb1 */
      name: string;
      description?: string;
      status: boolean;
      /**
       * @description Human friendly time duration for which a pool will uninterruptedly be selected in cluster_rr strategy, i.e. pools will switch once every time slice.
       * @default 0s
       */
      time_slice?: string;
      /** @enum {string} */
      method: "failover" | "cluster_rr" | "cluster_chash";
      pools?: components["schemas"]["LoadBalancerPoolStore"][];
    };
    LoadBalancerPoolStore: {
      id?: string;
      name: string;
      description?: string;
      status: boolean;
      /** @description Zero means the default pool */
      priority?: number;
      /** @enum {string} */
      method: "cluster_rr" | "cluster_chash";
      /**
       * @default off
       * @enum {string}
       */
      keepalive: "on" | "off";
      /**
       * @description Try another server when the first one failed if on
       * @default off
       * @enum {string}
       */
      next_upstream_tcp: "on" | "off";
      next_upstream_tcp_codes?: components["schemas"]["NextUpstreamTcpCodes"];
      regions?: string[];
      origins?: components["schemas"]["LoadBalancerOriginStore"][];
    };
    LoadBalancerOriginStore: {
      id?: string;
      name?: string;
      status: boolean;
      address: string;
      port: number;
      weight: number;
      /**
       * @default auto
       * @enum {string}
       */
      protocol: "auto" | "http" | "https";
      host_header?: string;
    };
    CacheSettings: {
      cache_developer_mode?: boolean;
      cache_consistent_uptime?: boolean;
      /** @enum {string} */
      cache_status?: "off" | "uri" | "query_string";
      /** @enum {string} */
      cache_page_200?: "0s" | "1s" | "2s" | "3s" | "4s" | "5s" | "6s" | "7s" | "8s" | "9s" | "10s" | "30s" | "1m" | "3m" | "5m" | "10m" | "30m" | "45m" | "1h" | "3h" | "5h" | "10h" | "12h" | "24h" | "3d" | "7d" | "10d" | "15d" | "30d";
      /** @enum {string} */
      cache_page_any?: "0s" | "1s" | "2s" | "3s" | "4s" | "5s" | "6s" | "7s" | "8s" | "9s" | "10s" | "30s" | "1m" | "3m" | "5m" | "10m" | "30m" | "45m" | "1h" | "3h" | "5h" | "10h" | "12h" | "24h" | "3d" | "7d" | "10d" | "15d" | "30d";
      /** @enum {string} */
      cache_browser?: "default" | "0s" | "1s" | "2s" | "3s" | "4s" | "5s" | "6s" | "7s" | "8s" | "9s" | "10s" | "30s" | "1m" | "3m" | "5m" | "10m" | "30m" | "45m" | "1h" | "3h" | "5h" | "10h" | "12h" | "24h" | "3d" | "7d" | "10d" | "15d" | "30d";
      /**
       * @deprecated
       * @description To consider scheme (HTTP/HTTPs) in cache
       */
      cache_scheme?: boolean;
      /** @description Ignore default behavior in caching set-cookie header */
      cache_ignore_sc?: boolean;
      /** @description Cookie variables to consider in cache (comma separaterd values) */
      cache_cookie?: string;
      /** @description To consider query args or not */
      cache_args?: boolean;
      /**
       * @description Query string arguments to consider in cache (& seperated values)
       * @default
       * @example filter&sort
       */
      cache_arg?: string;
    };
    CacheSettingsData: {
      data?: components["schemas"]["CacheSettings"];
    } & components["schemas"]["DataResponse"];
    ImageResize: {
      /**
       * @default off
       * @enum {string}
       */
      status?: "on" | "off";
      /** @default height */
      height_by?: string;
      /** @default width */
      width_by?: string;
    };
    ImageResizeResponse: {
      data?: components["schemas"]["ImageResize"];
    } & components["schemas"]["DataWithMessageResponse"];
    PageRuleImageResize: ({
      /** @enum {unknown} */
      status?: "on" | "off" | "inherit";
    }) & components["schemas"]["ImageResize"];
    Acceleration: {
      /** @enum {string} */
      status?: "inherit" | "on" | "off";
      /**
       * @default []
       * @example [
       *   "css",
       *   "js"
       * ]
       */
      extensions?: ("css" | "gif" | "jpeg" | "js" | "png")[];
    };
    AccelerationResponse: {
      data?: components["schemas"]["Acceleration"];
    } & components["schemas"]["DataWithMessageResponse"];
    AccelerationUpdate: ({
      /** @enum {string} */
      status?: "on" | "off";
    }) & components["schemas"]["Acceleration"];
    CustomPage: {
      /** @enum {integer} */
      status_code?: 200 | 302 | 481 | 403 | 482 | 483 | 484 | 500;
      /** @enum {string} */
      type?: "off" | "url" | "file";
      /** Format: url */
      url?: string;
    };
    CustomPages: {
      under_construction?: components["schemas"]["CustomPage"];
      firewall_error?: components["schemas"]["CustomPage"];
      waf_protection?: components["schemas"]["CustomPage"];
      rate_limit_exceeded?: components["schemas"]["CustomPage"];
      secure_link_expired?: components["schemas"]["CustomPage"];
      secure_link_invalid?: components["schemas"]["CustomPage"];
      error_500?: components["schemas"]["CustomPage"];
      ddos_js?: components["schemas"]["CustomPage"];
      ddos_captcha?: components["schemas"]["CustomPage"];
    };
    CustomPagesData: {
      data?: components["schemas"]["CustomPages"];
    } & components["schemas"]["DataResponse"];
    CustomPageUpdate: {
      /** @enum {string} */
      type?: "off" | "url" | "file";
      /**
       * @description ddos_js and ddos_captcha can only be used with file type
       * @enum {string}
       */
      page?: "under_construction" | "firewall_error" | "waf_protection" | "rate_limit_exceeded" | "secure_link_expired" | "secure_link_invalid" | "error_500" | "ddos_js" | "ddos_captcha";
      /** Format: url */
      url?: string;
      /** Format: binary */
      file?: string;
    };
    Redirect: {
      /** @enum {string} */
      f_redirect_to_www?: "off" | "www" | "root";
    };
    RedirectData: {
      data?: components["schemas"]["Redirect"];
    } & components["schemas"]["DataResponse"];
    UpdateBooleanStatus: {
      status?: boolean;
    };
    LogForwarder: {
      id?: string;
      name: string;
      description: string;
      /** @enum {string} */
      type: "access" | "waf" | "dns" | "error" | "event";
      /** @enum {string} */
      connection_type: "arvan_s3" | "alibaba_s3" | "amazon_s3" | "custom_s3" | "loggly" | "datadog" | "syslog" | "kafka";
      data_format: components["schemas"]["LogForwarderDataFormat"];
      settings: components["schemas"]["LogForwarderSetting"];
      status: boolean;
    };
    LogForwarderGeneric: {
      id?: string;
      name?: string;
      description?: string;
      /** @enum {string} */
      type?: "access" | "waf" | "dns" | "error";
      /** @enum {string} */
      connection_type?: "arvan_s3" | "alibaba_s3" | "amazon_s3" | "custom_s3" | "loggly" | "datadog" | "syslog" | "kafka";
      data_format?: Record<string, never>;
      settings?: Record<string, never>;
      status?: boolean;
    };
    LogForwarderResponse: {
      data?: components["schemas"]["LogForwarderGeneric"];
    } & components["schemas"]["DataWithMessageResponse"];
    LogForwarderDataFormat: components["schemas"]["LogForwarderAccessLogType"] | components["schemas"]["LogForwarderWAFType"] | components["schemas"]["LogForwarderDNSType"] | components["schemas"]["LogForwarderErrorType"] | components["schemas"]["LogForwarderEventType"];
    /** @description Access log type */
    LogForwarderAccessLogType: {
      method?: boolean;
      scheme?: boolean;
      domain?: boolean;
      uri?: boolean;
      query_string?: boolean;
      referer?: boolean;
      ip?: boolean;
      ua?: boolean;
      country?: boolean;
      asn?: boolean;
      content_type?: boolean;
      status?: boolean;
      tls_fingerprint?: boolean;
      server_port?: boolean;
      bytes_sent?: boolean;
      bytes_received?: boolean;
      upstream_time?: boolean;
      cache?: boolean;
      request_id?: boolean;
      timestamp?: boolean;
    };
    /** @description Waf log type */
    LogForwarderWAFType: {
      product?: boolean;
      timestamp?: boolean;
      remote_address?: boolean;
      domain?: boolean;
      data?: boolean;
    };
    /** @description Dns log type */
    LogForwarderDNSType: {
      timestamp?: boolean;
      uuid?: boolean;
      record?: boolean;
      type?: boolean;
      ip?: boolean;
      country?: boolean;
      asn?: boolean;
      response_code?: boolean;
      process_time?: boolean;
    };
    /** @description Event log type */
    LogForwarderEventType: {
      domain?: boolean;
      uuid?: boolean;
      timestamp?: boolean;
      method?: boolean;
      scheme?: boolean;
      ip?: boolean;
      country?: boolean;
      status?: boolean;
      server_ip?: boolean;
      server_port?: boolean;
      uri?: boolean;
      query_string?: boolean;
      firewall?: boolean;
      proxy?: boolean;
      dns_resolver?: boolean;
      ddos?: boolean;
      ratelimit?: boolean;
      waf?: boolean;
    };
    /** @description Error log type */
    LogForwarderErrorType: {
      client_ip?: boolean;
      upstream_proto?: boolean;
      upstream_uri?: boolean;
      upstream_port?: boolean;
      upstream_ip?: boolean;
      domain_name?: boolean;
      http_version?: boolean;
      request_method?: boolean;
      request_uri?: boolean;
      real_timestamp?: boolean;
      error_message?: boolean;
      pop_site?: boolean;
      request_id?: boolean;
    };
    LogForwarderSetting: components["schemas"]["LogForwarderS3ConnectionType"] | components["schemas"]["LogForwarderDatadogConnectionType"] | components["schemas"]["LogForwarderKafkaConnectionType"] | components["schemas"]["LogForwarderLogglyConnectionType"] | components["schemas"]["LogForwarderSyslogConnectionType"];
    /** @description ArvanS3, AmazonS3, AlibabaS3 and Custom S3 connections */
    LogForwarderS3ConnectionType: {
      sample_rate?: number;
      /** Format: hostname */
      s3_endpoint?: string;
      access_key?: string;
      secret_key?: string;
      bucket_name?: string;
      object_size?: number;
      flush_interval?: number;
    };
    /** @description Datadog connection */
    LogForwarderDatadogConnectionType: {
      sample_rate?: number;
      /** Format: url */
      url?: string;
      api_key?: string;
      app_key?: string;
      flush_interval?: number;
      buffer_size?: number;
    };
    /** @description Kafka connection */
    LogForwarderKafkaConnectionType: {
      sample_rate?: number;
      kafka_version?: string;
      kafka_brokers?: string[];
      kafka_topic_to_write?: string;
      kafka_producer_batch_size?: number;
      kafka_producer_flush_frequency_ms?: number;
    };
    /** @description Loggly connection */
    LogForwarderLogglyConnectionType: {
      sample_rate?: number;
      token?: string;
      /** Format: url */
      url?: string;
      flush_interval?: number;
      buffer_size?: number;
    };
    /** @description Syslog connection */
    LogForwarderSyslogConnectionType: {
      sample_rate?: number;
      /** @enum {string} */
      logtype?: "syslogudp" | "syslogtcp";
      /** Format: hostname, ip */
      host?: string;
      port?: number;
      tls?: boolean;
      cert?: string;
      retry_time?: number;
    };
    Troubleshoot: {
      /** Format: uuid */
      id?: string;
      details?: ({
          /** @enum {string} */
          id?: "root_dns_record" | "www_dns_record" | "mx_dns_record" | "https_redirection" | "domain_active_status" | "active_certificate" | "cloud_icon" | "domain_expiration_days" | "origin_ssl_port";
          /** @enum {string} */
          status?: "safe" | "troubled";
          details?: string;
        })[];
      created_at?: string;
    };
    FirewallSettings: {
      default_action_details?: components["schemas"]["FirewallActionDetails"];
    } & components["schemas"]["BaseFirewallSettings"];
    FirewallSettingsView: ({
      default_action_details?: Record<string, unknown> | null;
    }) & components["schemas"]["BaseFirewallSettings"];
    BaseFirewallSettings: {
      is_enabled?: boolean;
      /** @enum {string} */
      default_action?: "allow" | "deny" | "drop" | "bypass" | "challenge";
      /**
       * @description True to verify that SNI and hostname are equal
       * @default false
       */
      verify_sni?: boolean;
      /**
       * @description Shows hether global whitelist should be skipped for the domain or not
       * @default false
       */
      skip_global_whitelist?: boolean | null;
      /**
       * @description Shows whether global firewall should be skipped for the domain or not
       * @default false
       */
      skip_global_firewall?: boolean | null;
    };
    /** @description Details of bypass or challenge actions */
    FirewallActionDetails: components["schemas"]["BypassAction"] | components["schemas"]["ChallengeAction"] | null;
    FirewallRule: WithRequired<{
      action_details?: components["schemas"]["FirewallActionDetails"];
    } & components["schemas"]["BaseFirewallRule"], "name" | "filter_expr" | "action">;
    FirewallRuleView: {
      action_details?: Record<string, never>;
    } & components["schemas"]["BaseFirewallRule"];
    BaseFirewallRule: {
      /** Format: uuid */
      id?: string;
      name?: string;
      /**
       * @description Wireshark-like filter expression
       * @example ip.geoip.country in {"IR" "TH" "US"} and ssl
       */
      filter_expr?: string;
      /** @enum {string} */
      action?: "allow" | "deny" | "bypass" | "challenge";
      is_enabled?: boolean;
      note?: string;
    };
    FirewallRuleResponse: {
      data?: components["schemas"]["FirewallRuleView"];
    } & components["schemas"]["DataWithMessageResponse"];
    WafPreset: {
      id?: string;
      name?: string;
      description?: string;
      packages?: {
          name?: string;
          provider?: {
            name?: string;
            /** Format: url */
            logo?: string;
          };
        }[];
    };
    WafPresets: {
      presets?: components["schemas"]["WafPreset"][];
      packages?: components["schemas"]["WafPackage"][];
    };
    WafPresetsData: {
      data?: components["schemas"]["WafPresets"];
    } & components["schemas"]["DataResponse"];
    WafSettings: {
      is_enabled?: boolean;
      /** @enum {string} */
      mode?: "off" | "detect" | "protect";
      /** @description Pacakges and their configurations that are used to configure WAF. */
      packages?: readonly components["schemas"]["DomainWafPackage"][];
    };
    WafRule: {
      /** Format: uuid */
      id?: string;
      url_pattern?: components["schemas"]["GlobPattern"];
      sources?: components["schemas"]["CIDR"][];
      /** @enum {string} */
      action?: "protect" | "passthrough";
      description?: string;
      is_enabled?: boolean;
    };
    WafPackage: {
      id?: string;
      name?: string;
      provider?: {
        readonly name?: string;
        /** Format: url */
        readonly logo?: string;
      };
      /** @description JSON-schema of parameters of the package */
      params_schema?: Record<string, never>;
      /** @description It will be filled by default disabled rules when it's not provided */
      disabled_rules?: string[];
      /** @description It will be filled by default disabled rulesets when it's not provided */
      disabled_rulesets?: string[];
    };
    WafRuleset: {
      id?: string;
      name?: string;
      rules?: {
          id?: string;
          name?: string;
          /**
           * @example {
           *   "score": 8,
           *   "severity": 7
           * }
           */
          params?: Record<string, never>;
        }[];
    };
    WafRulesets: {
      rulesets?: components["schemas"]["WafRuleset"][];
    };
    WafPackageDetails: components["schemas"]["WafPackage"] & components["schemas"]["WafRulesets"];
    WafPackageDetailsData: {
      data?: components["schemas"]["WafPackageDetails"];
    } & components["schemas"]["DataResponse"];
    DomainWafPackage: {
      /** @description parameters of the package */
      params?: Record<string, never>;
      /** @default true */
      is_enabled?: boolean;
    } & components["schemas"]["WafPackage"];
    DomainWafPackageStore: {
      id: string;
    };
    DomainWafPackageDetails: components["schemas"]["DomainWafPackage"] & components["schemas"]["WafRulesets"];
    DomainWafPackageDetailsData: {
      data?: components["schemas"]["DomainWafPackageDetails"];
    } & components["schemas"]["DataResponse"];
    WafSettingsData: {
      data?: components["schemas"]["WafSettings"];
    } & components["schemas"]["DataResponse"];
    WafReconfigure: {
      /** Format: uuid */
      preset_id?: string;
    };
    WafReprioritize: {
      /**
       * Format: uuid
       * @description ID of the package you want to move
       */
      package_id: string;
      /**
       * Format: uuid
       * @description ID of the package you want to be prior to the selected package
       */
      after_package_id?: string;
      /**
       * Format: uuid
       * @description ID of the package you want to follow the selected package
       */
      before_package_id?: string;
    };
    WafRuleResponse: {
      data?: components["schemas"]["WafRule"];
    } & components["schemas"]["DataWithMessageResponse"];
    DomainWafPackagesData: {
      data?: components["schemas"]["DomainWafPackage"][];
    } & components["schemas"]["DataResponse"];
    DdosSettings: {
      is_enabled?: boolean;
      /** @enum {string} */
      protection_mode?: "off" | "cookie" | "javascript" | "captcha";
      /** @enum {string} */
      captcha_service?: "recaptcha" | "arcaptcha" | "hcaptcha";
      /** @description it can be configured when the captcha_service is set to arcaptcha */
      site_key?: string;
      /** @description it can be configured when the captcha_service is set to arcaptcha */
      secret_key?: string;
      /** @description Time in seconds for cookie max-age */
      ttl?: number;
      /** @description Adds "SameSite=None; Secure" to set-cookie header */
      https_only?: boolean;
      preflight?: components["schemas"]["DdosPreflight"];
    };
    DdosSettingsData: {
      data?: components["schemas"]["DdosSettings"];
    } & components["schemas"]["DataWithMessageResponse"];
    DdosPreflight: {
      access_origin?: string;
      access_credentials?: string;
      access_methods?: ("GET" | "HEAD" | "POST" | "PUT" | "DELETE" | "CONNECT" | "OPTIONS" | "TRACE" | "PATCH")[];
      access_headers?: string;
      access_expose_headers?: string;
    };
    DdosRule: {
      /** Format: uuid */
      id?: string;
      url_pattern?: components["schemas"]["GlobPattern"];
      sources?: components["schemas"]["CIDR"][];
      description?: string;
      /** @enum {string} */
      action?: "passthrough" | "protect";
      is_enabled?: boolean;
    };
    DdosRuleResponse: {
      data?: components["schemas"]["DdosRule"];
    } & components["schemas"]["DataWithMessageResponse"];
    DdosRuleData: {
      data?: components["schemas"]["DdosRule"];
    } & components["schemas"]["DataResponse"];
    RateLimitSettings: {
      ddos_detection?: boolean;
      exclude_sources?: components["schemas"]["CIDR"][];
    };
    RateLimitSettingsData: {
      data?: components["schemas"]["RateLimitSettings"];
    } & components["schemas"]["DataResponse"];
    RateLimitRule: {
      action_details?: components["schemas"]["ChallengeAction"];
    } & components["schemas"]["BaseRateLimitRule"];
    RateLimitRuleView: {
      action_details?: Record<string, never>;
    } & components["schemas"]["BaseRateLimitRule"];
    BaseRateLimitRule: {
      /** Format: uuid */
      id?: string;
      /**
       * @default block
       * @enum {string}
       */
      action?: "challenge" | "block";
      is_enabled?: boolean;
      url_pattern: components["schemas"]["GlobPattern"];
      description?: string | null;
      exclude_sources?: components["schemas"]["CIDR"][];
      rate: number;
      burst?: number;
      block_duration?: number;
      time_duration: number;
      allowed_methods?: ("POST" | "GET" | "PUT" | "HEAD" | "DELETE")[];
    };
    RateLimitRuleData: {
      data?: components["schemas"]["RateLimitRuleView"];
    } & components["schemas"]["DataResponse"];
    /**
     * Format: CIDR
     * @example 1.2.3.4/32
     */
    CIDR: string;
    /**
     * Format: glob pattern
     * @description - `?` matches any single character.
     * - `*` matches any (possibly empty) sequence of characters.
     * - `**` matches the current directory and arbitrary subdirectories. This sequence must form a single path component, so both `**a` and `b**` are invalid and will result in an error. A sequence of more than two consecutive `*` characters is also invalid.
     * - `[...]` matches any character inside the brackets. Character sequences can also specify ranges of characters, as ordered by Unicode, so e.g. `[0-9]` specifies any character between 0 and 9 inclusive. An unclosed bracket is invalid.
     * - `[!...]` is the negation of `[...]`, i.e. it matches any characters not in the brackets.
     * - The metacharacters `?`, `*`, `[`, `] `can be matched by using brackets (e.g. `[?]`). When a `]` occurs immediately following `[` or `[!` then it is interpreted as being part of, rather then ending, the character set, so `]` and NOT `]` can be matched by `[]]` and `[!]]` respectively. The - character can be specified inside a character sequence pattern by placing it at the start or the end, e.g. `[abc-]`.
     */
    GlobPattern: string;
    ReprioritizeRuleRequest: {
      /**
       * Format: uuid
       * @description ID of the rule you want to move
       */
      rule_id: string;
      /**
       * Format: uuid
       * @description ID of the rule you want to be prior to the selected rule
       */
      after_rule_id?: string;
      /**
       * Format: uuid
       * @description ID of the rule you want to follow the selected rule
       */
      before_rule_id?: string;
    };
    PrioritizePoolAfter: {
      /**
       * Format: uuid
       * @description ID of the pool you want to move
       */
      pool_id: string;
      /**
       * Format: uuid
       * @description ID of the pool you want to be prior to the selected pool
       */
      after_pool_id: string;
    };
    PrioritizePoolBefore: {
      /**
       * Format: uuid
       * @description ID of the pool you want to move
       */
      pool_id: string;
      /**
       * Format: uuid
       * @description ID of the pool you want to follow the selected pool
       */
      before_pool_id: string;
    };
    PrioritizePool: components["schemas"]["PrioritizePoolAfter"] | components["schemas"]["PrioritizePoolBefore"];
    readonly CdnAppLikeStats: {
      readonly likes_count?: number;
      readonly dislikes_count?: number;
    };
    CdnAppLikeStatsData: {
      data?: components["schemas"]["CdnAppLikeStats"];
    } & components["schemas"]["DataResponse"];
    CdnAppLike: {
      /** @description True means she likes, False means she dislikes, null means she wants to get her vote back. */
      like?: boolean | null;
    };
    CdnApp: {
      /** Format: uuid */
      id?: string;
      categories?: components["schemas"]["ApplicationCategory"][];
      /** @example 5 */
      rank?: number;
      name?: string;
      slug?: string;
      short_description?: string;
      description?: string;
      /** @description absolute link to logo image */
      logo?: string;
      pictures?: string[];
      vendor?: string;
      /** Format: email */
      support_email?: string;
      install_json?: components["schemas"]["InstallJson"];
      /** @enum {string} */
      status?: "published" | "draft";
      like_stats?: components["schemas"]["CdnAppLikeStats"];
      /** @description True means she likes, False means she dislikes. null means she did not vote. */
      like_by_user?: boolean;
      /** Format: date-time */
      created_at?: string;
      /** Format: date-time */
      updated_at?: string;
    };
    CdnAppInstall: {
      is_install?: boolean;
    };
    CdnAppData: {
      data?: components["schemas"]["CdnApp"];
    } & components["schemas"]["DataResponse"];
    DomainCdnApp: {
      /** Format: uuid */
      id?: string;
      /** Format: uuid */
      domain_id?: string;
      /** Format: uuid */
      application_id?: string;
      active?: boolean;
      options?: components["schemas"]["AppOptions"];
      /** Format: date-time */
      created_at?: string;
      /** Format: date-time */
      updated_at?: string;
    };
    CdnAppTriggerWebhook: {
      /** @enum {string} */
      event: "before-new-install" | "new-install";
      options: components["schemas"]["AppOptions"];
    };
    InstallJson: Record<string, never>;
    AppOptions: Record<string, never>;
    Certificate: {
      /** Format: uuid */
      id?: string;
      /** @enum {string} */
      type?: "arvan" | "user";
      /** @enum {string|null} */
      key_type?: "ec" | "rsa" | null;
      domain_names?: readonly string[];
      issuer?: string;
      /** Format: date-time */
      expiry_date?: string;
      /** Format: date-time */
      created_at?: string;
      /** Format: date-time */
      updated_at?: string;
    };
    CertificateOrder: {
      /** Format: uuid */
      id?: string;
      /** Format: int32 */
      order_id?: string;
      /**
       * @description - `unprocessed` - Order is in the process queue
       * - `canceled` - Order is canceled in favor of a new one with updated subject names
       * - `pending` - Authorization Challenges are set, Validating authorization challenges...
       * - `ready` - Challenges are validated, ready to issue the certificate
       * - `processing` - Issuing Certificate...
       * - `valid` - Certificate is issued successfully, this is the final stage
       * - `invalid` - An Error Occurred, this order cannot proceed anymore, a new order will be created automatically
       * - `terminated` - An Unknown Error occurred, this order cannot proceed anymore, a new order will be created automatically
       * - `killed` - Order failed despite many retries, will not proceed anymore nor retry, needs manual intervention
       *
       * @enum {string}
       */
      status?: "unprocessed" | "pending" | "processing" | "ready" | "valid" | "invalid" | "canceled" | "terminated" | "killed";
      domain_names?: readonly string[];
      errors?: readonly Record<string, never>[];
      /**
       * Format: date-time
       * @description Expired order is treated as invalid order
       */
      expiry_date?: string;
      /** Format: date-time */
      created_at?: string;
      /** Format: date-time */
      updated_at?: string;
    };
    Ssl: {
      /** @description Whether Domain is using fingerprint or not */
      fingerprint_status?: boolean;
      /** @description Whether Domain is using ssl module or not */
      ssl_status?: boolean;
      /**
       * @description Indicates certificate is managed by arvan, or its up to the user
       * @enum {string}
       */
      certificate_mode?: "managed" | "custom";
      /**
       * @description Minimum version of TLS. Empty ('') means default.
       * @enum {string}
       */
      tls_version?: "" | "TLSv1" | "TLSv1.1" | "TLSv1.2" | "TLSv1.3";
      /** @description Whether HSTS is enabled */
      hsts_status?: boolean;
      /**
       * @description HSTS max age directive
       * @enum {string}
       */
      hsts_max_age?: "1mo" | "2mo" | "3mo" | "4mo" | "5mo" | "6mo" | "12mo" | "24mo";
      hsts_subdomain?: boolean;
      hsts_preload?: boolean;
      https_redirect?: boolean;
      /** @description Replace HTTP with HTTPs in HTML and JS sources */
      replace_http?: boolean;
      /** @enum {string} */
      certificate_key_type?: "rsa" | "ec";
      certificates?: readonly components["schemas"]["Certificate"][];
      /** @description returns all "certificate orders" since the last invalid or canceled order */
      orders?: (readonly components["schemas"]["CertificateOrder"][]) | null;
    };
    SslResponse: {
      data?: components["schemas"]["Ssl"];
    } & components["schemas"]["DataWithMessageResponse"];
    CertificateStore: {
      /** Format: binary */
      certificate?: string;
      /** Format: binary */
      private_key?: string;
    };
    LogForwarderSummary: {
      id?: string;
      type?: string;
      connection_type?: string;
      name?: string;
      description?: string;
      status?: boolean;
    };
    TransportLayerProxy: {
      /** Format: uuid */
      id?: string;
      /** Format: date-time */
      created_at?: string;
      /** @enum {string} */
      status?: "healthy" | "initializing" | "failed";
      app_name?: string;
      description?: string;
      /** @example sub.example.com */
      domain?: string;
      port?: number;
      ip?: string | null;
      /** @enum {string} */
      proxy_protocol?: "off" | "send-proxy" | "send-proxy-v2";
      /** @enum {string} */
      balance_algorithm?: "roundrobin" | "leastconn" | "source";
      servers?: ({
          /** Format: hostname */
          address?: string;
          port?: number;
          weight?: number;
          /** @enum {string} */
          check?: "enabled" | "disabled";
          fall?: number;
          inter?: number;
          rise?: number;
        })[];
      /** @enum {string} */
      firewall_default_action?: "allow" | "deny";
      firewalls?: ({
          /** @enum {string} */
          access?: "allow" | "deny";
          name?: string;
          description?: string;
          /** @enum {string} */
          type?: "geo" | "ip_range";
          match?: components["schemas"]["TransportLayerProxyMatch"];
          active?: boolean;
        })[];
    };
    TransportLayerProxyMatch: components["schemas"]["TransportLayerProxyMatchCountry"] | components["schemas"]["TransportLayerProxyMatchIp"];
    /**
     * @description when type is geo
     * @example IR
     */
    TransportLayerProxyMatchCountry: string;
    /** @description when type is ip_range */
    TransportLayerProxyMatchIp: string[];
    TransportLayerProxyResponse: {
      data?: components["schemas"]["TransportLayerProxy"];
    } & components["schemas"]["DataWithMessageResponse"];
    TransportLayerProxyStore: {
      app_name: string;
      description?: string;
      /** @example sub.example.com */
      domain: string;
      port: number;
      /** @enum {string} */
      proxy_protocol: "off" | "send-proxy" | "send-proxy-v2";
      /** @enum {string} */
      balance_algorithm: "roundrobin" | "leastconn" | "source";
      servers?: components["schemas"]["TransportLayerProxyServer"][];
      /** @enum {string} */
      firewall_default_action: "allow" | "deny";
      firewalls?: components["schemas"]["TransportLayerProxyFirewall"][];
    };
    TransportLayerProxyUpdate: {
      app_name: string;
      description?: string;
      /** @example sub.example.com */
      domain?: string;
      port?: number;
      /** @enum {string} */
      proxy_protocol: "off" | "send-proxy" | "send-proxy-v2";
      /** @enum {string} */
      balance_algorithm: "roundrobin" | "leastconn" | "source";
      servers?: components["schemas"]["TransportLayerProxyServer"][];
      /** @enum {string} */
      firewall_default_action?: "allow" | "deny";
      firewalls?: components["schemas"]["TransportLayerProxyFirewall"][];
    };
    TransportLayerProxyFirewall: {
      /** @enum {string} */
      access?: "allow" | "deny";
      name?: string;
      description?: string;
      /** @enum {string} */
      type?: "geo" | "ip_range";
      match?: components["schemas"]["TransportLayerProxyMatch"];
      active?: boolean;
    };
    TransportLayerProxyServer: {
      /** Format: hostname */
      address: string;
      port: number;
      weight: number;
      /** @enum {string} */
      check: "enabled" | "disabled";
      fall?: number;
      inter?: number;
      rise?: number;
    };
    SslUpdate: ({
      /**
       * @description a user uploaded certificate's uuid or `managed`
       * @example [
       *   "managed",
       *   "4e0de55d-96f5-471b-8ee5-f2667738320e"
       * ]
       */
      certificate?: string;
      /** @enum {string} */
      certificate_key_type?: "rsa" | "ec";
    }) & components["schemas"]["Ssl"];
    HealthCheckReportDetail: {
      /** Format: datetime */
      date?: string;
      zone?: string;
      upstream?: string;
      status?: boolean;
      message?: string;
    };
    HealthCheckReportSummaryDetail: {
      /** Format: datetime */
      date?: string;
      status?: boolean;
    };
    HealthCheckReportSummary: {
      zone?: string;
      status?: boolean;
      total?: number;
      failed?: number;
      details?: components["schemas"]["HealthCheckReportSummaryDetail"][];
    };
    HealthCheckRequestConfig: components["schemas"]["HttpConfig"] | components["schemas"]["TcpConfig"];
    HealthCheckView: {
      request_config?: Record<string, never>;
    } & components["schemas"]["BaseHealthCheck"];
    HealthCheck: {
      request_config?: components["schemas"]["HealthCheckRequestConfig"];
    } & components["schemas"]["BaseHealthCheck"];
    BaseHealthCheck: {
      /** Format: uuid */
      id?: string;
      name?: string;
      description?: string;
      /** @description can be IP/Host when type is `upstream`, otherwise it must be a valid record ID */
      origin?: string;
      /** @enum {string} */
      origin_type?: "pool";
      upstreams?: string[];
      /** @description In milliseconds */
      interval?: number;
      threshold?: number;
      /** @enum {string} */
      type?: "TCP" | "HTTP" | "HTTPS";
      /**
       * @description The health-check is off or on
       * @default true
       */
      status?: boolean;
      /** @description Number of immediate retries in case of a timeout */
      retries?: number;
      zones?: components["schemas"]["HealthCheckZone"][];
      /** Format: date-time */
      monitoring_updated_at?: string | null;
    };
    HttpConfig: {
      /** @enum {string} */
      method: "HEAD" | "GET" | "POST" | "PUT";
      port: number;
      /** @description path for test */
      path: string;
      allow_insecure: boolean;
      expected_response: components["schemas"]["ExpectedResponse"];
      headers: {
        [key: string]: string;
      };
      follow_redirects?: boolean;
      /** @description In milliseconds */
      timeout: number;
    };
    TcpConfig: {
      port: number;
      /** @description In milliseconds */
      timeout: number;
    };
    HealthCheckZone: {
      id?: string;
      /** @enum {string} */
      monitoring_level?: "critical" | "non-critical" | "off";
    };
    HealthCheckZoneName: {
      id?: string;
      name?: string;
    };
    ExpectedResponse: {
      /** @description List of expected http status code */
      codes?: number[];
      headers?: components["schemas"]["Headers"];
      body?: string;
    };
    Headers: {
      [key: string]: string[];
    };
    /** @enum {string|null} */
    MonitoringStatus: "off" | "no-data" | "healthy" | "unhealthy" | null;
    HealthCheckResponse: {
      data?: components["schemas"]["HealthCheckView"];
    } & components["schemas"]["DataWithMessageResponse"];
    FeaturePrice: {
      metric_key?: string;
      currency?: string;
      value?: number;
    } | null;
    UsageLimit: {
      min?: number;
      max?: number;
    } | null;
    FeaturePricing: {
      free_tier?: number;
      flat?: components["schemas"]["FeaturePrice"];
      per_unit?: components["schemas"]["FeaturePrice"];
    } | null;
    Currency: {
      /** @enum {string} */
      key?: "irr" | "eur";
      label?: string;
    };
    PlanInfo: {
      /** @example enterprise */
      key?: string;
      name?: string;
      monthly_cost?: number;
      /** @description between 0 to 100 is the percentage of the discount */
      discount?: number;
      /** @description How much balance the account needs for selected plan */
      needed_balance?: number;
    };
    Plans: components["schemas"]["PlanInfo"][];
    FeaturePlanDefinition: ({
      meta?: {
        labels?: (string | boolean)[];
        tip?: string;
        available_params?: Record<string, never>[];
      };
      usage_limit?: components["schemas"]["UsageLimit"];
      pricing?: components["schemas"]["FeaturePricing"];
    }) | null;
    FeatureDefinition: {
      id?: string;
      plans?: {
        0?: components["schemas"]["FeaturePlanDefinition"];
        1?: components["schemas"]["FeaturePlanDefinition"];
        2?: components["schemas"]["FeaturePlanDefinition"];
        3?: components["schemas"]["FeaturePlanDefinition"];
        4?: components["schemas"]["FeaturePlanDefinition"];
      };
      meta?: {
        label?: string;
        description?: string;
      };
    };
    FeatureSet: {
      id?: string;
      label?: string;
      features?: components["schemas"]["FeatureDefinition"][];
    };
    EstimatedCost: {
      /** @enum {string} */
      period?: "monthly" | "dayly" | "hourly";
      /** @enum {string} */
      currency?: "IRT" | "EUR";
      value?: number;
    };
    FeatureUsage: {
      feature_id?: string;
      pricing?: components["schemas"]["FeaturePricing"];
      estimated_cost?: components["schemas"]["EstimatedCost"];
      usage?: number;
    };
    Violations: {
      violations?: {
        paygo?: string[];
        basic?: string[];
        growth?: string[];
        professional?: string[];
        enterprise?: string[];
      };
    };
    Usages: {
      feature_usages?: components["schemas"]["FeatureUsage"][];
      estimated_cost?: components["schemas"]["EstimatedCost"];
    };
    FeatureSets: {
      currency?: components["schemas"]["Currency"];
      plans?: components["schemas"]["Plans"];
      feature_sets?: components["schemas"]["FeatureSet"][];
    };
    PlanResponse: {
      data?: components["schemas"]["FeatureSets"];
    } & components["schemas"]["DataWithMessageResponse"];
    CachingPurge: {
      /**
       * @description tags is deprecated
       * @enum {string}
       */
      purge: "all" | "individual" | "tags";
      /** @description URLs to be purged from cache. Required if purge value is set to individual. */
      purge_urls?: string[];
      /**
       * @deprecated
       * @description Tags to be purged from cache. Required if purge value is set to tags.
       * Each tag must be 32 characters or less. Only ASCII characters are acceptable.
       */
      purge_tags?: string[];
    };
    DomainPurgeTags: {
      /** Format: uuid */
      domain_id?: string;
      tags?: string[];
      /** Format: date-time */
      created_at?: string;
      /** Format: date-time */
      updated_at?: string;
    };
    ApplicationCategory: {
      id?: string;
      name?: string;
      active?: boolean;
      order?: number;
      name_translation?: {
        en?: {
          name?: string;
        };
        fa?: {
          name?: string;
        };
      } | null;
      applications?: {
          /** Format: uuid */
          id?: string;
          slug?: string;
          name?: string;
          description?: string;
          logo?: string;
        }[];
    };
    CloneDomain: {
      /** Format: hostname */
      from: string;
    };
    BypassAction: {
      rlimit?: boolean;
      challenge?: boolean;
      waf?: boolean;
    };
    ChallengeAction: {
      /**
       * @description The mode of mitigation (1: Cookie, 2: Javascript, 3: Captcha)
       * @enum {integer}
       */
      mode?: 1 | 2 | 3;
      ttl?: number;
      https_only?: boolean;
    };
    DynamicField: {
      /** Format: uuid */
      id?: string;
      name: string;
      description?: string | null;
      namespace?: string;
      /** @enum {string} */
      type: "ip" | "number" | "byte";
      /** @enum {string} */
      scope?: "public" | "private";
      values: components["schemas"]["DynamicFieldValues"];
      /** Format: date-time */
      created_at?: string;
      /** Format: date-time */
      updated_at?: string;
    };
    DynamicFieldResponse: {
      data?: components["schemas"]["DynamicField"];
    } & components["schemas"]["DataWithMessageResponse"];
    DynamicFieldData: {
      data?: components["schemas"]["DynamicField"];
    } & components["schemas"]["DataResponse"];
    DynamicFieldValues: components["schemas"]["DynamicFieldValue"][];
    DynamicFieldValue: {
      value?: components["schemas"]["DynamicFieldType"];
      desc?: string;
      created_at?: string;
    };
    DynamicFieldType: components["schemas"]["DynamicFieldIpType"] | components["schemas"]["DynamicFieldByteType"] | components["schemas"]["DynamicFieldNumberType"];
    /** @description List of parameters and related errors */
    UnprocessableEntityErrorObject: {
      [key: string]: string;
    } | null;
    /** @description List of error messages */
    UnprocessableEntityErrorArray: string[][];
    /** @description List of error messages */
    UnprocessableEntityErrorStringArray: string[];
    /** @description List of error messages */
    UnprocessableEntityErrorArrays: {
      [key: string]: string[];
    };
    /**
     * IP
     * @description IPv4 or IPv6
     */
    DynamicFieldIpType: string;
    /** Number */
    DynamicFieldNumberType: number;
    /**
     * Byte
     * Format: byte
     */
    DynamicFieldByteType: string;
    MessageResponse: {
      message?: string;
    };
  };
  responses: {
    /** @description The given data was invalid */
    UnprocessableEntityError: {
      content: {
        "application/json": {
          /** @default false */
          status?: boolean;
          message?: string;
          errors?: components["schemas"]["UnprocessableEntityErrorStringArray"] | components["schemas"]["UnprocessableEntityErrorArray"] | components["schemas"]["UnprocessableEntityErrorArrays"] | components["schemas"]["UnprocessableEntityErrorObject"];
        };
      };
    };
    /** @description Successful */
    OK: {
      content: {
        "application/json": components["schemas"]["MessageResponse"];
      };
    };
    /** @description Coflict */
    Conflict: {
      content: {
        "application/json": components["schemas"]["MessageResponse"];
      };
    };
    /** @description Failed */
    Error: {
      content: {
        "application/json": components["schemas"]["MessageResponse"];
      };
    };
    /** @description Access token is missing or invalid */
    UnauthorizedError: {
      content: {
        "application/json": components["schemas"]["MessageResponse"];
      };
    };
    /** @description Access denied */
    AccessDenied: {
      content: {
        "application/json": components["schemas"]["MessageResponse"];
      };
    };
    /** @description Too many requests */
    TrottleRequests: {
      content: {
        "application/json": components["schemas"]["MessageResponse"];
      };
    };
    /** @description Resource not found */
    NotFoundError: {
      content: {
        "application/json": {
          /** @default false */
          status?: boolean;
        } & components["schemas"]["MessageResponse"];
      };
    };
  };
  parameters: {
    /**
     * @description Domain name
     * @example example.com
     */
    Domain: string;
    /** @description Domain name or id */
    DomainQuery?: string;
    /** @description Email forwarding id */
    EmailForwarding: string;
    /** @description Email forwarding recipient id */
    EmailForwardingRecipient: string;
    /** @description Email forwarding alias id */
    EmailForwardingAlias: string;
    /**
     * @description Comma separaterd plan levels to ignore
     * @example 0,1
     */
    IgnoredPlans?: string;
    /** @description Transport layer proxy id */
    TransportLayerProxyId: string;
    /**
     * @description Id of a WAF package
     * @example comodo
     */
    WafPackageId: string;
    Id: string;
    /** @description ID of the load balancer */
    LoadBalancerId: string;
    /** @description ID of a pool of the load balancer */
    LoadBalancerPoolId: string;
    /** @description ID of an origin of the pool in the load balancer */
    LoadBalancerPoolOriginId: string;
    PackageId: string;
    /** @description ID of the DNS record */
    DnsRecordId: string;
    /** @description Name of the health-check */
    HealthCheckName: string;
    /** @description Upstream of the health-check monitoring */
    HealthCheckUpstream: string;
    /** @description Type of reports for the health check */
    HealthCheckReportType?: "all" | "success" | "error";
    /** @description Search term */
    Search?: string;
    /** @description Set the direction of sorting */
    Direction?: "asc" | "desc";
    CdnAppSortBy?: "rank" | "likes";
    /** @description Set how many items returned per page */
    PerPage?: number;
    /** @description Set the desired page number */
    Page?: number;
    DynamicFieldScope?: "private" | "public";
    DynamicFieldType?: "ip" | "bytes" | "number";
    DynamicFieldName?: string;
    /** @description Select period -ending now- for report */
    ReportPeriod?: "1h" | "3h" | "6h" | "12h" | "24h" | "7d" | "30d";
    ReportSince?: string;
    ReportUntil?: string;
    FilterSubdomain?: string | null;
    /** @description Set the desired log */
    type?: "cdn" | "waf";
    /** @description Filter apps by category */
    CategoryId?: string;
    /** @description The id of the category */
    ApplicationCategory: string;
    ApplicationCategories?: string[] | null;
    HealthCheck: string;
    /**
     * @description Type of a dns record. To filter multiple types separate them using a comma
     * @example a,cname,txt
     */
    DnsRecordType?: string;
  };
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type $defs = Record<string, never>;

export type external = Record<string, never>;

export interface operations {

  /**
   * Get the list of domains
   * @description Leaving the 'search' empty, will return all domains. Otherwise, it will filter domains containing the search keyword.
   */
  "domains.index": {
    parameters: {
      query?: {
        search?: components["parameters"]["Search"];
        per_page?: components["parameters"]["PerPage"];
        page?: components["parameters"]["Page"];
      };
    };
    responses: {
      /** @description Lists all domains belongs to the account */
      200: {
        content: {
          "application/json": {
            data?: components["schemas"]["Domain"][];
          } & components["schemas"]["PaginatedResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
    };
  };
  /** Create new domain */
  "domains.store": {
    requestBody?: {
      content: {
        "application/json": components["schemas"]["DomainStore"];
      };
    };
    responses: {
      /** @description Successfully created the new domain */
      201: {
        content: {
          "application/json": components["schemas"]["DomainResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** Get information of the domain */
  "domains.show": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description Detailed information of the domain */
      200: {
        content: {
          "application/json": components["schemas"]["DomainResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Remove the domain */
  "domains.destroy": {
    parameters: {
      query: {
        id: string;
      };
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description Successfully deleted the domain */
      200: components["responses"]["OK"];
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** Set custom NS records for the domain */
  "domains.nameservers.set": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["NsKeys"];
      };
    };
    responses: {
      /** @description Successfully set custom NS values */
      200: {
        content: {
          "application/json": components["schemas"]["NsKeysResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      422: components["responses"]["Error"];
    };
  };
  /** Reset custom Nameserver keys to the default values for the domain */
  "domains.nameservers.reset": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description Successfully reset to deafult NS values */
      200: {
        content: {
          "application/json": components["schemas"]["NsKeysResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      422: components["responses"]["Error"];
    };
  };
  /** Check NS to find whether domain is activated */
  "domains.nameservers.check": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description Successfully retrieve list of NS values */
      200: {
        content: {
          "application/json": {
            data?: components["schemas"]["NsDomain"];
          } & components["schemas"]["DataWithMessageResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /**
   * Deprecated in favor /ns-keys/check
   * @deprecated
   */
  "domains.nameservers.deprecated-check": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description Successfully queued checking domain's NS */
      200: {
        content: {
          "application/json": {
            data?: components["schemas"]["DeprecatedNs"];
          } & components["schemas"]["DataWithMessageResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Use optional NS keys */
  "domains.nameservers.optional": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description Optional keys are set */
      200: {
        content: {
          "application/json": components["schemas"]["NsKeysResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Set a custom record for using CNAME Setup */
  "domains.cname-setup.set": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["CustomCname"];
      };
    };
    responses: {
      /** @description Successfully updated the custom cname record of the domain */
      200: {
        content: {
          "application/json": components["schemas"]["DomainResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** Reset the custom record of CNAME Setup to the default value */
  "domains.cname-setup.reset": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description Successfully updated the custom cname record of the domain */
      200: {
        content: {
          "application/json": components["schemas"]["DomainResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** Convert domain setup to cname */
  "domains.cname-setup.convert": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description Successfully converted the domain to use CNAME Setup */
      200: {
        content: {
          "application/json": components["schemas"]["DomainResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** Check Cname Setup to find whether domain is activated */
  "domains.cname-setup.check": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description Successfully converted the domain to use CNAME Setup */
      200: {
        content: {
          "application/json": components["schemas"]["DomainResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Clone a domain config from another one */
  "domains.clone": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["CloneDomain"];
      };
    };
    responses: {
      200: components["responses"]["OK"];
      400: components["responses"]["Error"];
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Regenerate domain settings for edge servers */
  "domains.regenerate": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description Domain settings are regenerated successfully */
      202: components["responses"]["OK"];
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Get the list of pending transfers */
  "domains.transfer.index": {
    parameters: {
      query?: {
        per_page?: components["parameters"]["PerPage"];
        page?: components["parameters"]["Page"];
        type?: "all" | "incoming" | "outgoing";
      };
    };
    responses: {
      /** @description Lists all pending transfers */
      200: {
        content: {
          "application/json": {
            data?: components["schemas"]["DomainTransferData"][];
          } & components["schemas"]["PaginatedResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
    };
  };
  /** Transfer domain to another account */
  "domains.transfer.store": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["TransferDomain"];
      };
    };
    responses: {
      /** @description the transfer request sent */
      200: {
        content: {
          "application/json": components["schemas"]["DomainTransferData"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Accept or cancel transferring a domain */
  "domains.transfer.update": {
    requestBody?: {
      content: {
        "application/json": components["schemas"]["TransferDomainChangeStatus"];
      };
    };
    responses: {
      /** @description Status Changed */
      200: components["responses"]["OK"];
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Get the list of feature defintions for plans based on different sets */
  "plans.index": {
    parameters: {
      query?: {
        domain?: components["parameters"]["DomainQuery"];
        ignored_plans?: components["parameters"]["IgnoredPlans"];
      };
    };
    responses: {
      /** @description List of feature defintions for plans based on different sets */
      200: {
        content: {
          "application/json": components["schemas"]["PlanResponse"];
        };
      };
    };
  };
  /** Get the list of feature defintions for plans based on different sets */
  "domains.plans": {
    parameters: {
      query?: {
        ignored_plans?: components["parameters"]["IgnoredPlans"];
      };
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description List of feature defintions for plans based on different sets */
      200: {
        content: {
          "application/json": components["schemas"]["PlanResponse"];
        };
      };
    };
  };
  /** Update the domain's plan */
  "domains.plans.update": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["PlanUpdate"];
      };
    };
    responses: {
      /** @description Successfully updated the plan */
      200: components["responses"]["OK"];
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** Get violations based on plans */
  "domains.plans.violations": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description List of feature definitions and violations */
      200: {
        content: {
          "application/json": {
            data?: components["schemas"]["Violations"];
          } & components["schemas"]["DataWithMessageResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Get usages based on features and an estimated cost */
  "domains.plans.usages": {
    parameters: {
      query?: {
        target_plan?: components["schemas"]["Plan"];
      };
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description List of features with usages and total estimated cost */
      200: {
        content: {
          "application/json": {
            data?: components["schemas"]["Usages"];
          } & components["schemas"]["DataWithMessageResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Get list of DNS records */
  "dns-records.index": {
    parameters: {
      query?: {
        search?: components["parameters"]["Search"];
        type?: components["parameters"]["DnsRecordType"];
        page?: components["parameters"]["Page"];
        per_page?: components["parameters"]["PerPage"];
      };
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description Successfully retrieved list of DNS records */
      200: {
        content: {
          "application/json": {
            data?: components["schemas"]["DnsRecordGeneric"][];
          } & components["schemas"]["PaginatedResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Create new DNS record */
  "dns-records.store": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["DnsRecord"];
      };
    };
    responses: {
      /** @description Successfully created new DNS record */
      201: {
        content: {
          "application/json": components["schemas"]["DnsRecordResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** Get information of a record */
  "dns-records.show": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        id: components["parameters"]["DnsRecordId"];
      };
    };
    responses: {
      /** @description Successfully retrieved the record's information */
      200: {
        content: {
          "application/json": components["schemas"]["DnsRecordData"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Update a DNS record */
  "dns-records.update": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        id: components["parameters"]["DnsRecordId"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["DnsRecord"];
      };
    };
    responses: {
      /** @description Successfully updated the record */
      200: {
        content: {
          "application/json": components["schemas"]["DnsRecordResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** Remove a DNS record */
  "dns-records.destroy": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        id: components["parameters"]["DnsRecordId"];
      };
    };
    responses: {
      /** @description Successfully removed the record */
      200: components["responses"]["OK"];
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Toggle cloud status (To proxy or not proxy, that's the question!) */
  "dns-records.cloud": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        id: components["parameters"]["DnsRecordId"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["DnsRecordCloud"];
      };
    };
    responses: {
      /** @description Successfully updated cloud status */
      200: {
        content: {
          "application/json": components["schemas"]["DnsRecordResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** Import DNS records using BIND file */
  "dns-records.import": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    requestBody?: {
      content: {
        "multipart/form-data": components["schemas"]["DnsRecordImport"];
      };
    };
    responses: {
      /** @description Successfully imported DNS records */
      200: components["responses"]["OK"];
    };
  };
  /** Get status of DNSSEC */
  "dns-records.dns-sec.show": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description Status and configuration of DNSSEC */
      200: {
        content: {
          "application/json": components["schemas"]["DnsSecData"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Update DNSSEC status */
  "dns-records.dns-sec.update": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["DnsSecStatus"];
      };
    };
    responses: {
      /** @description Successfully updated DNSSEC status */
      200: {
        content: {
          "application/json": components["schemas"]["DnsSecData"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** Get caching settings */
  "caching.index": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description Successfully retrieved caching settings */
      200: {
        content: {
          "application/json": components["schemas"]["CacheSettingsData"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /**
   * Purge CDN Cache
   * @deprecated
   * @description Purge CDN cache, either by URLs, tags, or the whole site.
   * Purge by tag is only available for domains with Professional plan or higher.
   */
  "caching.deprecated_purge": {
    parameters: {
      query: {
        purge: "all" | "individual" | "tags";
        /** @description URLs to be purged from cache. Required if purge value is set to individual. */
        purge_urls?: string[];
        /**
         * @deprecated
         * @description Tags to be purged from cache. Required if purge value is set to tags.
         * Each tag must be 32 characters or less. Only ASCII characters are acceptable.
         */
        purge_tags?: string[];
      };
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description Successfully queued purgestring */
      200: components["responses"]["OK"];
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** Update caching settings */
  "caching.update": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["CacheSettings"];
      };
    };
    responses: {
      /** @description Successfully updated caching settings */
      200: components["responses"]["OK"];
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /**
   * Purge CDN Cache
   * @description Purge CDN cache, either by URLs, tags, or the whole site.
   * Purge by tag is only available for domains with Professional plan or higher.
   */
  "caching.purge": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["CachingPurge"];
      };
    };
    responses: {
      /** @description Successfully queued purge */
      201: components["responses"]["OK"];
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /**
   * Get domain's Purge tags
   * @deprecated
   * @description Returns last 100 purged tags sorted by recency.
   */
  "purge_tags.index": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description Successfully retrieved Domain's Purge Tags */
      200: {
        content: {
          "application/json": {
            data?: components["schemas"]["DomainPurgeTags"];
          } & components["schemas"]["DataResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /**
   * Delete a Domain's Purge tag
   * @deprecated
   */
  "purge_tags.destroy": {
    parameters: {
      query: {
        tag: string;
      };
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description Successfully Delete Domain's Purge tag */
      200: components["responses"]["OK"];
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Get list of regions for load balancers */
  "load-balancers.regions.index": {
    responses: {
      /** @description Successfully retrieved list of regions for load balancers */
      200: {
        content: {
          "application/json": {
            data?: components["schemas"]["LoadBalancerRegion"][];
          } & components["schemas"]["DataResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Get list of domain load balancer global settings */
  "load-balancers.settings.show": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description Successfully retrieved list of settings */
      200: {
        content: {
          "application/json": components["schemas"]["LoadBalancerSettingsData"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Update domain's global load balancer settings */
  "load-balancers.settings.update": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["LoadBalancerSetting"];
      };
    };
    responses: {
      /** @description Successfully updated settings */
      200: {
        content: {
          "application/json": {
            data?: components["schemas"]["LoadBalancerSetting"];
          } & components["schemas"]["DataWithMessageResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** Get list of load balancers */
  "load-balancers.index": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description Successfully retrieved list of load balancers */
      200: {
        content: {
          "application/json": {
            data?: components["schemas"]["LoadBalancer"][];
          } & components["schemas"]["DataResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Create a new load balancer */
  "load-balancers.store": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["LoadBalancerStore"];
      };
    };
    responses: {
      /** @description Successfully created load balancer */
      201: {
        content: {
          "application/json": components["schemas"]["LoadBalancerResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** Get load balancer information */
  "load-balancers.show": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        loadBalancerId: components["parameters"]["LoadBalancerId"];
      };
    };
    responses: {
      /** @description Successfully retrieved load balancer data */
      200: {
        content: {
          "application/json": components["schemas"]["LoadBalancerData"];
        };
      };
    };
  };
  /** Update a load balancer */
  "load-balancers.updateWithPools": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        loadBalancerId: components["parameters"]["LoadBalancerId"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["LoadBalancerStore"];
      };
    };
    responses: {
      /** @description Successfully updated a load balancer */
      200: {
        content: {
          "application/json": components["schemas"]["LoadBalancerResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** Remove a load balancer */
  "load-balancers.destroy": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        loadBalancerId: components["parameters"]["LoadBalancerId"];
      };
    };
    responses: {
      /** @description Successfully removed a load balancer */
      200: components["responses"]["OK"];
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** Update a load balancer */
  "load-balancers.update": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        loadBalancerId: components["parameters"]["LoadBalancerId"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["LoadBalancer"];
      };
    };
    responses: {
      /** @description Successfully updated a load balancer */
      200: {
        content: {
          "application/json": components["schemas"]["LoadBalancerResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** Get the list of pools of a load balancers */
  "load-balancers.pools.index": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        loadBalancerId: components["parameters"]["LoadBalancerId"];
      };
    };
    responses: {
      /** @description Successfully retrieved list of pools of the load balancers */
      200: {
        content: {
          "application/json": {
            data?: components["schemas"]["LoadBalancerPool"][];
          } & components["schemas"]["DataResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Create a new pool for the load balancer */
  "load-balancers.pools.store": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        loadBalancerId: components["parameters"]["LoadBalancerId"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["LoadBalancerPoolStore"];
      };
    };
    responses: {
      /** @description Successfully created pool of the load balancer */
      201: {
        content: {
          "application/json": components["schemas"]["LoadBalancerPoolResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** Reorder the priority of load balancer pools */
  "load-balancers.prioritize_pool": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        loadBalancerId: components["parameters"]["LoadBalancerId"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["PrioritizePool"];
      };
    };
    responses: {
      /** @description Successfully prioritized pools in the load balancer */
      200: {
        content: {
          "application/json": components["schemas"]["LoadBalancerResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** Get load balancer pool information */
  "load-balancers.pools.show": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        loadBalancerId: components["parameters"]["LoadBalancerId"];
        loadBalancerPoolId: components["parameters"]["LoadBalancerPoolId"];
      };
    };
    responses: {
      /** @description Successfully retrieved load balancer pool data */
      200: {
        content: {
          "application/json": components["schemas"]["LoadBalancerPoolData"];
        };
      };
    };
  };
  /** Update an existing load balancer pool with origins */
  "load-balancers.pools.update": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        loadBalancerId: components["parameters"]["LoadBalancerId"];
        loadBalancerPoolId: components["parameters"]["LoadBalancerPoolId"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["LoadBalancerPoolStore"];
      };
    };
    responses: {
      /** @description Successfully updated a load balancer */
      200: {
        content: {
          "application/json": components["schemas"]["LoadBalancerPoolResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** Remove a load balancer pool */
  "load-balancers.pools.destroy": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        loadBalancerId: components["parameters"]["LoadBalancerId"];
        loadBalancerPoolId: components["parameters"]["LoadBalancerPoolId"];
      };
    };
    responses: {
      /** @description Successfully removed a load balancer pool */
      200: components["responses"]["OK"];
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** Update an existing load balancer pool without origins */
  "load-balancers.pools.updatePool": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        loadBalancerId: components["parameters"]["LoadBalancerId"];
        loadBalancerPoolId: components["parameters"]["LoadBalancerPoolId"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["LoadBalancerPoolStore"];
      };
    };
    responses: {
      /** @description Successfully updated a load balancer */
      200: {
        content: {
          "application/json": components["schemas"]["LoadBalancerPoolResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** Get list of origins of a pool */
  "load-balancers.pools.origins.index": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        loadBalancerId: components["parameters"]["LoadBalancerId"];
        loadBalancerPoolId: components["parameters"]["LoadBalancerPoolId"];
      };
    };
    responses: {
      /** @description Successfully retrieved list of origins of a pool */
      200: {
        content: {
          "application/json": {
            data?: components["schemas"]["LoadBalancerOrigin"][];
          } & components["schemas"]["DataResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Create a new origin in the pool of the load balancer */
  "load-balancers.pools.origins.store": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        loadBalancerId: components["parameters"]["LoadBalancerId"];
        loadBalancerPoolId: components["parameters"]["LoadBalancerPoolId"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["LoadBalancerOriginStore"];
      };
    };
    responses: {
      /** @description Successfully created load balancer */
      201: {
        content: {
          "application/json": components["schemas"]["LoadBalancerOriginResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** Get load balancer origin information */
  "load-balancers.pools.origins.show": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        loadBalancerId: components["parameters"]["LoadBalancerId"];
        loadBalancerPoolId: components["parameters"]["LoadBalancerPoolId"];
        loadBalancerPoolOriginId: components["parameters"]["LoadBalancerPoolOriginId"];
      };
    };
    responses: {
      /** @description Successfully retrieved the origin data */
      200: {
        content: {
          "application/json": components["schemas"]["LoadBalancerOriginData"];
        };
      };
    };
  };
  /** Remove an origin from the pool of the load balancer */
  "load-balancers.pools.origins.destroy": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        loadBalancerId: components["parameters"]["LoadBalancerId"];
        loadBalancerPoolId: components["parameters"]["LoadBalancerPoolId"];
        loadBalancerPoolOriginId: components["parameters"]["LoadBalancerPoolOriginId"];
      };
    };
    responses: {
      /** @description Successfully removed the origin */
      200: components["responses"]["OK"];
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** Update an existing origin of the pool */
  "load-balancers.pools.origins.update": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        loadBalancerId: components["parameters"]["LoadBalancerId"];
        loadBalancerPoolId: components["parameters"]["LoadBalancerPoolId"];
        loadBalancerPoolOriginId: components["parameters"]["LoadBalancerPoolOriginId"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["LoadBalancerOriginStore"];
      };
    };
    responses: {
      /** @description Successfully updated the origin of the pool */
      200: {
        content: {
          "application/json": components["schemas"]["LoadBalancerOriginResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** Get list of page-rules */
  "page-rules.index": {
    parameters: {
      query?: {
        search?: components["parameters"]["Search"];
        per_page?: components["parameters"]["PerPage"];
        page?: components["parameters"]["Page"];
        /** @description Sort page rules in ascending or descending order base on seq */
        order?: "desc" | "asc";
      };
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description Successfully retrieved list of page-rules */
      200: {
        content: {
          "application/json": {
            data?: components["schemas"]["PageRuleSummary"][];
          } & components["schemas"]["PaginatedResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Create new page-rule */
  "page-rules.store": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["PageRule"];
      };
    };
    responses: {
      /** @description Successfully created new page-rule */
      200: {
        content: {
          "application/json": components["schemas"]["PageRuleResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** Get the page-rule's information */
  "page-rules.show": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        id: components["parameters"]["Id"];
      };
    };
    responses: {
      /** @description Successfully retrieved page-rule information */
      200: {
        content: {
          "application/json": components["schemas"]["PageRuleData"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Update the page-rule */
  "page-rules.update": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        id: components["parameters"]["Id"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["PageRule"];
      };
    };
    responses: {
      /** @description Successfully updated page-rule information */
      200: {
        content: {
          "application/json": components["schemas"]["PageRuleResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** Delete the page-rule */
  "page-rules.destroy": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        id: components["parameters"]["Id"];
      };
    };
    responses: {
      /** @description Successfully deleted the page-rule */
      200: components["responses"]["OK"];
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Toggle status of the page-rule */
  "page-rules.status.update": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        id: components["parameters"]["Id"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["UpdateBooleanStatus"];
      };
    };
    responses: {
      /** @description Successfully updated the page-rule */
      200: components["responses"]["OK"];
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** Purge the page-rule */
  "page-rules.purge": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        id: components["parameters"]["Id"];
      };
    };
    responses: {
      /** @description Successfully purged page-rule */
      200: components["responses"]["OK"];
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** Get the page-rule's exceptions */
  "page-rules.diff.show": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        id: components["parameters"]["Id"];
      };
    };
    responses: {
      /** @description Successfully retrieved page-rule information */
      200: {
        content: {
          "application/json": components["schemas"]["PageRuleDiffData"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Update the page-rule's exceptions */
  "page-rules.diff.update": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        id: components["parameters"]["Id"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["PageRule"];
      };
    };
    responses: {
      /** @description Successfully updated page-rule */
      200: {
        content: {
          "application/json": {
            data?: components["schemas"]["PageRuleDiff"];
          } & components["schemas"]["DataWithMessageResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** Get the content of image resize settings */
  "image-resize.show": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description Successful */
      200: {
        content: {
          "application/json": components["schemas"]["ImageResizeResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Update the content of image resize settings */
  "image-resize.update": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["ImageResize"];
      };
    };
    responses: {
      /** @description Successful */
      200: {
        content: {
          "application/json": components["schemas"]["ImageResizeResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** Get the content of acceleration settings */
  "acceleration.show": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description Successful */
      200: {
        content: {
          "application/json": components["schemas"]["AccelerationResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Update the content of acceleration settings */
  "acceleration.update": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["AccelerationUpdate"];
      };
    };
    responses: {
      /** @description Successful */
      200: {
        content: {
          "application/json": components["schemas"]["AccelerationResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** Get list of custom pages */
  "custom-pages.show": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description Successful */
      200: {
        content: {
          "application/json": components["schemas"]["CustomPagesData"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Update custom page */
  "custom-pages.update": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    requestBody?: {
      content: {
        "multipart/form-data": components["schemas"]["CustomPageUpdate"];
      };
    };
    responses: {
      /** @description Successfully updated custom page */
      200: components["responses"]["OK"];
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** Get redirect settings */
  "redirect.show": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": components["schemas"]["RedirectData"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Update redirect settings */
  "redirect.update": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["Redirect"];
      };
    };
    responses: {
      /** @description Success */
      200: components["responses"]["OK"];
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** Show list of log forwarders for given domain */
  "log-forwarders.index": {
    parameters: {
      query?: {
        per_page?: components["parameters"]["PerPage"];
        page?: components["parameters"]["Page"];
      };
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description List of log forwarders */
      200: {
        content: {
          "application/json": {
            data?: components["schemas"]["LogForwarderSummary"][];
          } & components["schemas"]["PaginatedResponse"];
        };
      };
    };
  };
  /** Create new log forwarder */
  "log-forwarders.store": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["LogForwarder"];
      };
    };
    responses: {
      /** @description Successfully created a new log forwarder */
      201: {
        content: {
          "application/json": components["schemas"]["LogForwarderResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** Show a log forwarder's details based on given id */
  "log-forwarders.show": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        /** @description Log Forwarder Id */
        logForwarderId: string;
      };
    };
    responses: {
      /** @description Details of a log forwarder */
      200: {
        content: {
          "application/json": components["schemas"]["LogForwarderResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      403: components["responses"]["AccessDenied"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Update a log forwarder */
  "log-forwarders.update": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        /** @description Log Forwarder Id */
        logForwarderId: string;
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["LogForwarder"];
      };
    };
    responses: {
      /** @description Update log forwarder successfully */
      200: {
        content: {
          "application/json": components["schemas"]["LogForwarderResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      403: components["responses"]["AccessDenied"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** Delete a log forwarder */
  "log-forwarders.destroy": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        /** @description Log Forwarder Id */
        logForwarderId: string;
      };
    };
    responses: {
      /** @description Delete log forwarder successfully */
      200: components["responses"]["OK"];
      401: components["responses"]["UnauthorizedError"];
      403: components["responses"]["AccessDenied"];
    };
  };
  /** Update a log forwarder's status */
  "log-forwarders.update.status": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        /** @description Log Forwarder Id */
        logForwarderId: string;
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["UpdateBooleanStatus"];
      };
    };
    responses: {
      /** @description Update log forwarder successfully */
      200: {
        content: {
          "application/json": components["schemas"]["LogForwarderResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      403: components["responses"]["AccessDenied"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** Show list of transport layer proxies for given domain */
  "transport-layer-proxies.index": {
    parameters: {
      query?: {
        per_page?: components["parameters"]["PerPage"];
        page?: components["parameters"]["Page"];
      };
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description List of transport layer proxies */
      200: {
        content: {
          "application/json": {
            data?: components["schemas"]["TransportLayerProxy"][];
          } & components["schemas"]["PaginatedResponse"];
        };
      };
    };
  };
  /** Create new transport layer proxy */
  "transport-layer-proxies.store": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["TransportLayerProxyStore"];
      };
    };
    responses: {
      /** @description Successfully created a new transport layer proxy */
      201: {
        content: {
          "application/json": components["schemas"]["TransportLayerProxyResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** Show a transport layer proxy's details based on given id */
  "transport-layer-proxies.show": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        transportLayerProxyId: components["parameters"]["TransportLayerProxyId"];
      };
    };
    responses: {
      /** @description Show details of a transport layer proxy */
      200: {
        content: {
          "application/json": components["schemas"]["TransportLayerProxyResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      403: components["responses"]["AccessDenied"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Update a transport layer proxy */
  "transport-layer-proxies.update": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        transportLayerProxyId: components["parameters"]["TransportLayerProxyId"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["TransportLayerProxyUpdate"];
      };
    };
    responses: {
      /** @description Update transport layer proxy successfully */
      200: {
        content: {
          "application/json": components["schemas"]["TransportLayerProxyResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      403: components["responses"]["AccessDenied"];
      404: components["responses"]["NotFoundError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** delete a transport layer proxy */
  "transport-layer-proxies.destroy": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        transportLayerProxyId: components["parameters"]["TransportLayerProxyId"];
      };
    };
    responses: {
      /** @description Delete transport layer proxy successfully */
      200: components["responses"]["OK"];
      401: components["responses"]["UnauthorizedError"];
      403: components["responses"]["AccessDenied"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Show stats of domain's email forwarding */
  "email-forwardings.stats": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description Stats of domain's email forwarding */
      200: {
        content: {
          "application/json": components["schemas"]["EmailForwardingStatsData"];
        };
      };
    };
  };
  /** Activate email forwarding */
  "email-forwardings.activate": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description Successfully activated email forwarding */
      201: components["responses"]["OK"];
      /** @description Already activated */
      409: components["responses"]["Conflict"];
    };
  };
  /** Deactivate email forwarding */
  "email-forwardings.deactivate": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description Successfully de-activated email forwarding */
      200: components["responses"]["OK"];
      /** @description Already de-activated */
      409: components["responses"]["Conflict"];
    };
  };
  /** Activate email forwarding catch all */
  "email-forwardings.catch_all.activate": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description Successfully activated email forwarding catch all */
      200: components["responses"]["OK"];
      /** @description Already activated */
      409: components["responses"]["Conflict"];
    };
  };
  /** Deactivate email forwarding catch all */
  "email-forwardings.catch_all.deactivate": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description Successfully de-activated email forwarding catch all */
      200: components["responses"]["OK"];
      /** @description Already de-activated */
      409: components["responses"]["Conflict"];
    };
  };
  /** List recipients of an email forwarding */
  "email-forwardings.recipients.index": {
    parameters: {
      query?: {
        per_page?: components["parameters"]["PerPage"];
        page?: components["parameters"]["Page"];
      };
      path: {
        domain: components["parameters"]["Domain"];
        emailForwardingId: components["parameters"]["EmailForwarding"];
      };
    };
    responses: {
      /** @description List recipients of an email forwarding */
      200: {
        content: {
          "application/json": components["schemas"]["EmailForwardingRecipientsListData"];
        };
      };
    };
  };
  /** Create new recipient */
  "email-forwardings.recipients.store": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        emailForwardingId: components["parameters"]["EmailForwarding"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["EmailForwardingRecipientsStore"];
      };
    };
    responses: {
      /** @description Recipient created successfully */
      201: {
        content: {
          "application/json": {
            data?: components["schemas"]["EmailForwardingRecipient"];
          } & components["schemas"]["DataWithMessageResponse"];
        };
      };
      /** @description Email already */
      409: components["responses"]["Conflict"];
    };
  };
  /** Delete a recipient */
  "email-forwardings.recipients.destroy": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        emailForwardingId: components["parameters"]["EmailForwarding"];
        emailForwardingRecipientId: components["parameters"]["EmailForwardingRecipient"];
      };
    };
    responses: {
      /** @description Recipient deleted successfully */
      200: components["responses"]["OK"];
      /** @description Server internal error */
      500: components["responses"]["Error"];
    };
  };
  /** Set default recipient */
  "email-forwardings.recipients.set_default": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        emailForwardingId: components["parameters"]["EmailForwarding"];
        emailForwardingRecipientId: components["parameters"]["EmailForwardingRecipient"];
      };
    };
    responses: {
      /** @description Default recipient is set successfully */
      200: components["responses"]["OK"];
      /** @description Not allowed to perform this action */
      403: components["responses"]["AccessDenied"];
      /** @description Recipient is already the default recipient */
      409: components["responses"]["Conflict"];
    };
  };
  /** Verify recipient */
  "email-forwardings.recipients.verify": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        emailForwardingId: components["parameters"]["EmailForwarding"];
        emailForwardingRecipientId: components["parameters"]["EmailForwardingRecipient"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["EmailForwardingRecipientsVerify"];
      };
    };
    responses: {
      /** @description Recipient verified successfully */
      200: components["responses"]["OK"];
      /** @description Recipient is already verified */
      409: components["responses"]["Conflict"];
    };
  };
  /** Resend Verification */
  "email-forwardings.recipients.resend_verification": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        emailForwardingId: components["parameters"]["EmailForwarding"];
        emailForwardingRecipientId: components["parameters"]["EmailForwardingRecipient"];
      };
    };
    responses: {
      /** @description Verification sent successfully */
      200: components["responses"]["OK"];
      /** @description Recipient is already verified */
      409: components["responses"]["Conflict"];
    };
  };
  /** List of email forwarding aliases for given domain */
  "email-forwardings.aliases.index": {
    parameters: {
      query?: {
        per_page?: components["parameters"]["PerPage"];
        page?: components["parameters"]["Page"];
      };
      path: {
        domain: components["parameters"]["Domain"];
        emailForwardingId: components["parameters"]["EmailForwarding"];
      };
    };
    responses: {
      /** @description List recipients of an email forwarding */
      200: {
        content: {
          "application/json": components["schemas"]["EmailForwardingAliasesListData"];
        };
      };
    };
  };
  /** Create new alias */
  "email-forwardings.aliases.store": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        emailForwardingId: components["parameters"]["EmailForwarding"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["EmailForwardingAliasesStore"];
      };
    };
    responses: {
      /** @description Alias created successfully */
      201: {
        content: {
          "application/json": {
            data?: components["schemas"]["EmailForwardingAlias"];
          } & components["schemas"]["DataWithMessageResponse"];
        };
      };
    };
  };
  /** Delete an alias */
  "email-forwardings.aliases.destroy": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        emailForwardingId: components["parameters"]["EmailForwarding"];
        emailForwardingAliasId: components["parameters"]["EmailForwardingAlias"];
      };
    };
    responses: {
      /** @description Alias deleted successfully */
      204: components["responses"]["OK"];
    };
  };
  /** Toggle alias activation */
  "email-forwardings.aliases.toggle_activation": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        emailForwardingId: components["parameters"]["EmailForwarding"];
        emailForwardingAliasId: components["parameters"]["EmailForwardingAlias"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["EmailForwardingAliasesToggleActivation"];
      };
    };
    responses: {
      /** @description Alias deleted successfully */
      204: components["responses"]["OK"];
    };
  };
  /** Update alias recipients */
  "email-forwardings.aliases.update_recipients": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        emailForwardingId: components["parameters"]["EmailForwarding"];
        emailForwardingAliasId: components["parameters"]["EmailForwardingAlias"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["EmailForwardingAliasesRecipients"];
      };
    };
    responses: {
      /** @description Recipients updated successfully */
      200: components["responses"]["OK"];
    };
  };
  /** Show list of troubleshoots for given domain */
  "troubleshoots.index": {
    parameters: {
      query?: {
        per_page?: components["parameters"]["PerPage"];
        page?: components["parameters"]["Page"];
      };
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description List of troubleshoots */
      200: {
        content: {
          "application/json": {
            data?: components["schemas"]["Troubleshoot"][];
          } & components["schemas"]["DataResponse"];
        };
      };
    };
  };
  /** Create new troubleshoot */
  "troubleshoots.store": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description Successfully created a new troubleshoot */
      201: {
        content: {
          "application/json": {
            data?: components["schemas"]["Troubleshoot"];
          } & components["schemas"]["DataResponse"];
        };
      };
      404: components["responses"]["NotFoundError"];
      429: components["responses"]["TrottleRequests"];
    };
  };
  /** Show the latest troubleshoot for given domain */
  "troubleshoots.latest": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description Details of a troubleshoot */
      200: {
        content: {
          "application/json": {
            data?: components["schemas"]["Troubleshoot"];
          } & components["schemas"]["DataResponse"];
        };
      };
    };
  };
  /** Get traffic report for domain */
  "reports.traffics.total": {
    parameters: {
      query?: {
        period?: components["parameters"]["ReportPeriod"];
        since?: components["parameters"]["ReportSince"];
        until?: components["parameters"]["ReportUntil"];
        "filter[subdomain]"?: components["parameters"]["FilterSubdomain"];
      };
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": components["schemas"]["TrafficsData"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** Get traffic saved to total pie chart */
  "reports.traffics.saved": {
    parameters: {
      query?: {
        period?: components["parameters"]["ReportPeriod"];
        since?: components["parameters"]["ReportSince"];
        until?: components["parameters"]["ReportUntil"];
        "filter[subdomain]"?: components["parameters"]["FilterSubdomain"];
      };
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": components["schemas"]["SavedTrafficsData"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** Get traffic as geo-map */
  "reports.traffics.map": {
    parameters: {
      query?: {
        period?: components["parameters"]["ReportPeriod"];
        since?: components["parameters"]["ReportSince"];
        until?: components["parameters"]["ReportUntil"];
        "filter[subdomain]"?: components["parameters"]["FilterSubdomain"];
      };
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": components["schemas"]["MapTrafficsData"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** Get report of visitors for domain */
  "reports.visitors.index": {
    parameters: {
      query?: {
        period?: components["parameters"]["ReportPeriod"];
        since?: components["parameters"]["ReportSince"];
        until?: components["parameters"]["ReportUntil"];
        "filter[subdomain]"?: components["parameters"]["FilterSubdomain"];
      };
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": components["schemas"]["VisitorsData"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** Get report of IPs with highest number of requests */
  "reports.visitors.high-request-ips": {
    parameters: {
      query?: {
        period?: components["parameters"]["ReportPeriod"];
        since?: components["parameters"]["ReportSince"];
        until?: components["parameters"]["ReportUntil"];
        per_page?: components["parameters"]["PerPage"];
        page?: components["parameters"]["Page"];
      };
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": {
            data?: components["schemas"]["HighRequestedIp"][];
          } & components["schemas"]["PaginatedResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** Get response time report */
  "reports.response-time.index": {
    parameters: {
      query?: {
        period?: components["parameters"]["ReportPeriod"];
        since?: components["parameters"]["ReportSince"];
        until?: components["parameters"]["ReportUntil"];
        "filter[subdomain]"?: components["parameters"]["FilterSubdomain"];
      };
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": components["schemas"]["ResponseTimeData"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** Get status codes pie chart */
  "reports.status.index": {
    parameters: {
      query?: {
        period?: components["parameters"]["ReportPeriod"];
        since?: components["parameters"]["ReportSince"];
        until?: components["parameters"]["ReportUntil"];
      };
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": components["schemas"]["StatusCodeReportData"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** Get an overview of status codes pie chart */
  "reports.status.summary": {
    parameters: {
      query?: {
        period?: components["parameters"]["ReportPeriod"];
        since?: components["parameters"]["ReportSince"];
        until?: components["parameters"]["ReportUntil"];
      };
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": components["schemas"]["StatusCodeSummaryData"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** Get list of errors */
  "reports.error-logs": {
    parameters: {
      query?: {
        period?: components["parameters"]["ReportPeriod"];
        since?: components["parameters"]["ReportSince"];
        until?: components["parameters"]["ReportUntil"];
      };
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": components["schemas"]["ErrorLogsData"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** Get chart view of errors */
  "reports.error-logs.chart": {
    parameters: {
      query?: {
        period?: components["parameters"]["ReportPeriod"];
        since?: components["parameters"]["ReportSince"];
        until?: components["parameters"]["ReportUntil"];
      };
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": components["schemas"]["ErrorLogChartData"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /**
   * Get detail of an error
   * @deprecated
   */
  "reports.error-log-details": {
    parameters: {
      query?: {
        period?: components["parameters"]["ReportPeriod"];
        since?: components["parameters"]["ReportSince"];
        until?: components["parameters"]["ReportUntil"];
        /** @description Error message to search for */
        error?: string;
      };
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": {
            data?: Record<string, never>;
          };
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** Get response time report */
  "reports.dns.requests": {
    parameters: {
      query?: {
        period?: components["parameters"]["ReportPeriod"];
        since?: components["parameters"]["ReportSince"];
        until?: components["parameters"]["ReportUntil"];
      };
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": components["schemas"]["DnsRequestReportData"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** Get DNS requests as geo-map */
  "reports.dns.geo": {
    parameters: {
      query?: {
        period?: components["parameters"]["ReportPeriod"];
        since?: components["parameters"]["ReportSince"];
        until?: components["parameters"]["ReportUntil"];
      };
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": components["schemas"]["DnsGeoReportData"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** Get report of attacks */
  "reports.attacks.show": {
    parameters: {
      query?: {
        period?: components["parameters"]["ReportPeriod"];
      };
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": {
            data?: components["schemas"]["AttackReport"];
          } & components["schemas"]["DataResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** Get list of attacks details */
  "reports.attacks.index": {
    parameters: {
      query?: {
        period?: components["parameters"]["ReportPeriod"];
        per_page?: components["parameters"]["PerPage"];
        page?: components["parameters"]["Page"];
      };
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": {
            data?: components["schemas"]["AttackReportItem"][];
          } & components["schemas"]["PaginatedResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** Get list of attackers information */
  "reports.attacks.attackers": {
    parameters: {
      query?: {
        period?: components["parameters"]["ReportPeriod"];
      };
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": {
            data?: {
                /** Format: ipv4 */
                ip?: string;
                count?: number;
              }[];
          } & components["schemas"]["DataResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** Get geo-map of attacks */
  "reports.attacks.map": {
    parameters: {
      query?: {
        period?: components["parameters"]["ReportPeriod"];
      };
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": components["schemas"]["AttackReportMapData"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** Get list of URLs under attack */
  "reports.attacks.uri": {
    parameters: {
      query?: {
        period?: components["parameters"]["ReportPeriod"];
      };
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": components["schemas"]["AttackReportUriData"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** Get traffic report for transport layer proxy */
  "reports.transport_layer_proxies.traffics": {
    parameters: {
      query?: {
        period?: components["parameters"]["ReportPeriod"];
        since?: components["parameters"]["ReportSince"];
        until?: components["parameters"]["ReportUntil"];
      };
      path: {
        domain: components["parameters"]["Domain"];
        transportLayerProxyId: components["parameters"]["TransportLayerProxyId"];
      };
    };
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": components["schemas"]["TransportLayerProxyTrafficsData"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** Get traffic report for multiple domains */
  "bulk-reports.traffics.total": {
    parameters: {
      query?: {
        period?: components["parameters"]["ReportPeriod"];
        since?: components["parameters"]["ReportSince"];
        until?: components["parameters"]["ReportUntil"];
      };
    };
    requestBody?: {
      content: {
        "application/json": {
          /** @description List of domains' IDs */
          domains?: string[];
          /** @description Whether to include sub-domains or report only root domain traffic */
          excludeSubdomains?: boolean;
        };
      };
    };
    responses: {
      /** @description Bulk operation was successful, see items for status of each item. */
      200: {
        content: {
          "application/json": components["schemas"]["BulkTrafficReportData"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** Get visitor report for multiple domains */
  "bulk-reports.visitors.total": {
    parameters: {
      query?: {
        period?: components["parameters"]["ReportPeriod"];
        since?: components["parameters"]["ReportSince"];
        until?: components["parameters"]["ReportUntil"];
      };
    };
    requestBody?: {
      content: {
        "application/json": {
          /** @description List of domains' IDs */
          domains?: string[];
          /** @description Whether to include sub-domains or report only root domain traffic */
          excludeSubdomains?: unknown;
        };
      };
    };
    responses: {
      /** @description Bulk operation was successful, see items for status of each item. */
      200: {
        content: {
          "application/json": components["schemas"]["BulkVisitorReportData"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** Get domain's firewall configuration */
  "firewall.settings.index": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description Successful */
      200: {
        content: {
          "application/json": {
            data?: components["schemas"]["FirewallSettingsView"];
          } & components["schemas"]["DataWithMessageResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Update domain's firewall configuration */
  "firewall.settings.update": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["FirewallSettings"];
      };
    };
    responses: {
      /** @description Updated Successfully */
      200: {
        content: {
          "application/json": {
            data?: components["schemas"]["FirewallSettingsView"];
          } & components["schemas"]["DataWithMessageResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Get domain's firewall rules */
  "firewall.rules.index": {
    parameters: {
      query?: {
        per_page?: number;
        order_by?: "priority" | "created_at";
        order_type?: "desc" | "asc";
        search?: string;
      };
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      200: {
        content: {
          "application/json": {
            data?: components["schemas"]["FirewallRuleView"][];
          } & components["schemas"]["PaginatedResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Create new firewall rule */
  "firewall.rules.store": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["FirewallRule"];
      };
    };
    responses: {
      /** @description Successfully created firewall rule */
      201: {
        content: {
          "application/json": components["schemas"]["FirewallRuleResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Get firewall rule information */
  "firewall.rules.show": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        id: components["parameters"]["Id"];
      };
    };
    responses: {
      /** @description Successful */
      200: {
        content: {
          "application/json": components["schemas"]["FirewallRuleResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Delete firewall rule */
  "firewall.rules.destroy": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        id: components["parameters"]["Id"];
      };
    };
    responses: {
      /** @description Successfully deleted the rule. */
      200: components["responses"]["OK"];
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Update the firewall rule */
  "firewall.rules.update": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        id: components["parameters"]["Id"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["FirewallRule"];
      };
    };
    responses: {
      /** @description Successfully updated the rule. */
      200: {
        content: {
          "application/json": components["schemas"]["FirewallRuleResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /**
   * Change priority of firewall rules
   * @description You can choose a firewall rule and request to put it after or before another rule.
   * You should only provide either after_rule_id or before_rule_id (and not both of them).
   */
  "firewall.reprioritize": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["ReprioritizeRuleRequest"];
      };
    };
    responses: {
      /** @description Successfully changed the priority of the rule. */
      200: components["responses"]["OK"];
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Get WAF presets */
  "global.waf.index": {
    responses: {
      /** @description Found list of presets */
      200: {
        content: {
          "application/json": components["schemas"]["WafPresetsData"];
        };
      };
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Get WAF package details */
  "global.waf.show_package": {
    parameters: {
      path: {
        packageId: components["parameters"]["PackageId"];
      };
    };
    responses: {
      /** @description Retrieved detail of package */
      200: {
        content: {
          "application/json": components["schemas"]["WafPackageDetailsData"];
        };
      };
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Get WAF configuration */
  "waf.settings.index": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description Successfully retrieved list of WAF settings */
      200: {
        content: {
          "application/json": components["schemas"]["WafSettingsData"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Configure WAF module of the domain */
  "waf.settings.update": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["WafSettings"];
      };
    };
    responses: {
      /** @description Successfully retrieved list of WAF settings */
      200: {
        content: {
          "application/json": components["schemas"]["WafSettingsData"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /**
   * Reconfigure WAF module using a preset
   * @description It remove all existing WAF packages and configures packages as defined in the preset
   */
  "waf.reconfigure": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["WafReconfigure"];
      };
    };
    responses: {
      /** @description Successfully changed the priority of the rule. */
      200: components["responses"]["OK"];
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /**
   * Change priority of WAF rules
   * @description You can choose a WAF rule and request to put it after or before another rule.
   * You should only provide either after_rule_id or before_rule_id (and not both of them).
   */
  "waf.reprioritize": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["ReprioritizeRuleRequest"];
      };
    };
    responses: {
      /** @description Successfully changed the priority of the rule. */
      200: components["responses"]["OK"];
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /**
   * Change priority of WAF packages
   * @description You can choose a WAF package and request to put it after or before another one.
   * You should only provide either after_package_id or before_package_id (and not both of them).
   */
  "waf.package.reprioritize": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["WafReprioritize"];
      };
    };
    responses: {
      /** @description Successfully changed the priority of the package. */
      200: components["responses"]["OK"];
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Get WAF Rules */
  "waf.rules.index": {
    parameters: {
      query?: {
        per_page?: number;
        order_by?: "priority" | "created_at";
        order_type?: "desc" | "asc";
        search?: string;
      };
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description Successfully created WAF rule */
      200: {
        content: {
          "application/json": {
            data?: components["schemas"]["WafRule"][];
          } & components["schemas"]["PaginatedResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Create new WAF rule */
  "waf.rules.store": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["WafRule"];
      };
    };
    responses: {
      /** @description Successfully created WAF rule */
      201: {
        content: {
          "application/json": components["schemas"]["WafRuleResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Get WAF rule information */
  "waf.rules.show": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        id: components["parameters"]["Id"];
      };
    };
    responses: {
      /** @description Successful */
      200: {
        content: {
          "application/json": components["schemas"]["WafRuleResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Delete WAF rule */
  "waf.rules.destroy": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        id: components["parameters"]["Id"];
      };
    };
    responses: {
      /** @description Successfully deleted the rule. */
      200: components["responses"]["OK"];
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Update the WAF rule */
  "waf.rules.update": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        id: components["parameters"]["Id"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["WafRule"];
      };
    };
    responses: {
      /** @description Successfully updated the rule. */
      200: {
        content: {
          "application/json": components["schemas"]["WafRuleResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /**
   * Get WAF packages
   * @description By passing `available` parameter in query string, it will return available packages for this domain.
   * Otherwise it lists currently added packages.
   */
  "waf.packages.index": {
    parameters: {
      query?: {
        available?: boolean;
      };
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description Retrieved list of WAF packages */
      200: {
        content: {
          "application/json": components["schemas"]["DomainWafPackagesData"];
        };
      };
    };
  };
  /** Add new WAF package to domain */
  "waf.packages.store": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["DomainWafPackageStore"];
      };
    };
    responses: {
      /** @description Successfully added WAF package */
      200: {
        content: {
          "application/json": {
            data?: components["schemas"]["DomainWafPackage"];
          } & components["schemas"]["DataWithMessageResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Get WAF package information */
  "waf.packages.show": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        id: string;
      };
    };
    responses: {
      /** @description Successful */
      200: {
        content: {
          "application/json": components["schemas"]["DomainWafPackageDetailsData"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Delete WAF package from domain */
  "waf.packages.destroy": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        id: string;
      };
    };
    responses: {
      /** @description Successfully deleted the package. */
      200: components["responses"]["OK"];
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Update the WAF package */
  "waf.packages.update": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        id: string;
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["DomainWafPackage"];
      };
    };
    responses: {
      /** @description Successfully updated the package. */
      200: {
        content: {
          "application/json": {
            data?: components["schemas"]["DomainWafPackageDetails"];
          } & components["schemas"]["DataWithMessageResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Get DDoS protection settings */
  "ddos.settings.index": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description Successfully retrieved DDoS settings */
      200: {
        content: {
          "application/json": components["schemas"]["DdosSettingsData"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Update domain's DDoS protection configuration */
  "ddos.settings.update": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["DdosSettings"];
      };
    };
    responses: {
      /** @description Successful */
      200: {
        content: {
          "application/json": {
            data?: components["schemas"]["DdosSettings"];
          } & components["schemas"]["DataWithMessageResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Get DDoS Protection Rules */
  "ddos.rules.index": {
    parameters: {
      query?: {
        per_page?: number;
        order_by?: "priority" | "created_at";
        order_type?: "desc" | "asc";
        search?: string;
      };
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description Successful */
      200: {
        content: {
          "application/json": {
            data?: components["schemas"]["DdosRule"][];
          } & components["schemas"]["PaginatedResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Create new DDoS protection rule */
  "ddos.rules.store": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["DdosRule"];
      };
    };
    responses: {
      /** @description Successfully created DDoS rule */
      201: {
        content: {
          "application/json": components["schemas"]["DdosRuleResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Get DDoS protection's rule information */
  "ddos.rules.show": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        id: components["parameters"]["Id"];
      };
    };
    responses: {
      /** @description Successful */
      200: {
        content: {
          "application/json": components["schemas"]["DdosRuleData"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Delete DDoS protection rule */
  "ddos.rules.destroy": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        id: components["parameters"]["Id"];
      };
    };
    responses: {
      /** @description Successfully deleted the rule. */
      200: components["responses"]["OK"];
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Update the DDoS protection rule */
  "ddos.rules.update": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        id: components["parameters"]["Id"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["DdosRule"];
      };
    };
    responses: {
      /** @description Successfully updated the rule. */
      200: {
        content: {
          "application/json": components["schemas"]["DdosRuleResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /**
   * Change priority of ddos rules
   * @description You can choose a DDoS rule and request to put it after or before another rule.
   * You should only provide either after_rule_id or before_rule_id (and not both of them).
   */
  "ddos.reprioritize": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["ReprioritizeRuleRequest"];
      };
    };
    responses: {
      /** @description Successfully changed the priority of the rule. */
      200: components["responses"]["OK"];
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Get Rate limiting settings */
  "rate-limiting.settings.index": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description Successfully retrieved Rate-Limit settings */
      200: {
        content: {
          "application/json": components["schemas"]["RateLimitSettingsData"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Update domain's Rate limiting configuration */
  "rate-limiting.settings.update": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["RateLimitSettings"];
      };
    };
    responses: {
      /** @description Successful */
      200: {
        content: {
          "application/json": {
            data?: components["schemas"]["RateLimitSettings"];
          } & components["schemas"]["DataWithMessageResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Get Rate limiting rules */
  "rate-limiting.rules.index": {
    parameters: {
      query?: {
        per_page?: number;
        order_by?: "priority" | "created_at";
        order_type?: "desc" | "asc";
        search?: string;
      };
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description Successful */
      200: {
        content: {
          "application/json": {
            data?: components["schemas"]["RateLimitRuleView"][];
          } & components["schemas"]["PaginatedResponse"];
        };
      };
    };
  };
  /** Store new Rate limiting rule */
  "rate-limiting.rules.store": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["RateLimitRule"];
      };
    };
    responses: {
      /** @description Successfully created Rate-Limit rule */
      201: {
        content: {
          "application/json": components["schemas"]["RateLimitRuleData"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Get Rate limiting's rule information */
  "rate-limiting.rules.show": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        id: components["parameters"]["Id"];
      };
    };
    responses: {
      /** @description Successful */
      200: {
        content: {
          "application/json": components["schemas"]["RateLimitRuleData"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Delete Rate limiting's rule */
  "rate-limiting.rules.destroy": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        id: components["parameters"]["Id"];
      };
    };
    responses: {
      /** @description Successfully deleted the rule. */
      200: components["responses"]["OK"];
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Update the Rate limiting's rule */
  "rate-limiting.rules.update": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        id: components["parameters"]["Id"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["RateLimitRule"];
      };
    };
    responses: {
      /** @description Successfully updated the rule. */
      200: {
        content: {
          "application/json": {
            data?: components["schemas"]["RateLimitRuleView"];
          } & components["schemas"]["DataWithMessageResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /**
   * Change priority of Rate limiting's rules
   * @description You can choose a rule and request to put it after or before another rule.
   * You should only provide either after_rule_id or before_rule_id (and not both of them).
   */
  "rate-limiting.actions.reprioritize": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["ReprioritizeRuleRequest"];
      };
    };
    responses: {
      /** @description Successfully changed the priority of the rule. */
      200: components["responses"]["OK"];
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Get list of all available cdn-apps */
  "apps.index": {
    parameters: {
      query?: {
        category_id?: components["parameters"]["CategoryId"];
        search?: components["parameters"]["Search"];
        per_page?: components["parameters"]["PerPage"];
        page?: components["parameters"]["Page"];
        sort_by?: components["parameters"]["CdnAppSortBy"];
        direction?: components["parameters"]["Direction"];
      };
    };
    responses: {
      /** @description Successful */
      200: {
        content: {
          "application/json": {
            data?: components["schemas"]["CdnApp"][];
          } & components["schemas"]["PaginatedResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
    };
  };
  /** Get a single cdn-app */
  "apps.show": {
    parameters: {
      path: {
        id: components["parameters"]["Id"];
      };
    };
    responses: {
      /** @description Successful */
      200: {
        content: {
          "application/json": components["schemas"]["CdnAppData"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Expressing like and dislike about a single cdn-app */
  "apps.like": {
    parameters: {
      path: {
        id: components["parameters"]["Id"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["CdnAppLike"];
      };
    };
    responses: {
      /** @description Successful */
      200: {
        content: {
          "application/json": components["schemas"]["CdnAppLikeStatsData"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Get list of all applications installed on a domain */
  "domains.apps.index": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description Successful */
      200: {
        content: {
          "application/json": {
            data?: components["schemas"]["CdnApp"][];
          } & components["schemas"]["PaginatedResponse"];
        };
      };
    };
  };
  /** Check the application is installed on the domain */
  "domains.apps.installed": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        id: components["parameters"]["Id"];
      };
    };
    responses: {
      /** @description Successfully retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["CdnAppInstall"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** Install the application on the domain */
  "domains.apps.store": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        id: components["parameters"]["Id"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["AppOptions"];
      };
    };
    responses: {
      /** @description Successfully installed the application. */
      200: {
        content: {
          "application/json": {
            data?: components["schemas"]["DomainCdnApp"];
          } & components["schemas"]["DataWithMessageResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** Uninstall the application from domain */
  "domains.apps.destroy": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        id: components["parameters"]["Id"];
      };
    };
    responses: {
      /** @description Successfully uninstalled the app. */
      200: components["responses"]["OK"];
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** trigger webhook event */
  "domains.apps.trigger-webhook": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        id: components["parameters"]["Id"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["CdnAppTriggerWebhook"];
      };
    };
    responses: {
      /** @description Successfully triggered webhook. */
      200: components["responses"]["OK"];
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** Get the list of application categories */
  "apps.category.index": {
    parameters: {
      query?: {
        categories?: components["parameters"]["ApplicationCategories"];
      };
    };
    responses: {
      /** @description Successful */
      200: {
        content: {
          "application/json": {
            data?: components["schemas"]["ApplicationCategory"][];
          } & components["schemas"]["PaginatedResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Get an existing application category */
  "apps.category.show": {
    parameters: {
      path: {
        "application-category": components["parameters"]["ApplicationCategory"];
      };
    };
    responses: {
      /** @description Successful */
      200: {
        content: {
          "application/json": {
            data?: components["schemas"]["ApplicationCategory"];
          } & components["schemas"]["DataWithMessageResponse"];
        };
      };
    };
  };
  /** Get SSL settings */
  "ssl.index": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description Successfully retrieved SSL settings */
      200: {
        content: {
          "application/json": components["schemas"]["SslResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Update domain's SSL settings */
  "ssl.update": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["SslUpdate"];
      };
    };
    responses: {
      /** @description Successful */
      200: {
        content: {
          "application/json": components["schemas"]["SslResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Upload Certificate */
  "ssl.cert.store": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    requestBody?: {
      content: {
        "multipart/form-data": components["schemas"]["CertificateStore"];
      };
    };
    responses: {
      /** @description Successful */
      201: components["responses"]["OK"];
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** Delete an unused customer certificate */
  "ssl.cert.destroy": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        id: components["parameters"]["Id"];
      };
    };
    responses: {
      /** @description Successful */
      200: components["responses"]["OK"];
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** Get All Managed certificate orders history */
  "ssl.cert.order.index": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description Successfully retrieved Managed SSL orders info */
      200: {
        content: {
          "application/json": {
            data?: components["schemas"]["CertificateOrder"][];
          } & components["schemas"]["DataWithMessageResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Retry a previously `killed` order */
  "ssl.cert.order.retry": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description Successfully placed a retry order */
      201: components["responses"]["OK"];
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** Get Defined HealthCheck */
  "active-health-check.index": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description Successfully retrieved HealthCheck settings */
      200: {
        content: {
          "application/json": {
            data?: components["schemas"]["HealthCheckView"][];
          } & components["schemas"]["DataWithMessageResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Store a new HealthCheck */
  "active-health-check.store": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["HealthCheck"];
      };
    };
    responses: {
      /** @description Successfully */
      201: {
        content: {
          "application/json": components["schemas"]["HealthCheckResponse"];
        };
      };
    };
  };
  /** Get a single healthcheck */
  "active-health-check.show": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        healthcheck: components["parameters"]["HealthCheck"];
      };
    };
    responses: {
      /** @description Successfully */
      200: {
        content: {
          "application/json": components["schemas"]["HealthCheckResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Delete healthcheck */
  "active-health-check.destroy": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        healthcheck: components["parameters"]["HealthCheck"];
      };
    };
    responses: {
      /** @description Successfully deleted the resource. */
      200: components["responses"]["OK"];
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Update Health check */
  "active-health-check.update": {
    parameters: {
      path: {
        domain: components["parameters"]["Domain"];
        healthcheck: components["parameters"]["HealthCheck"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["HealthCheck"];
      };
    };
    responses: {
      /** @description Successfully updated. */
      200: {
        content: {
          "application/json": components["schemas"]["HealthCheckResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** Get summary reports of a single healthcheck monitoring */
  "active-health-check.reports.summary": {
    parameters: {
      query: {
        name: components["parameters"]["HealthCheckName"];
        upstream: components["parameters"]["HealthCheckUpstream"];
        period?: components["parameters"]["ReportPeriod"];
        since?: components["parameters"]["ReportSince"];
        until?: components["parameters"]["ReportUntil"];
        direction?: components["parameters"]["Direction"];
      };
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description Successfully */
      200: {
        content: {
          "application/json": {
            data?: components["schemas"]["HealthCheckReportSummary"][];
          } & components["schemas"]["DataWithMessageResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Get reports of a single healthcheck monitoring */
  "active-health-check.reports.details": {
    parameters: {
      query: {
        name: components["parameters"]["HealthCheckName"];
        upstream: components["parameters"]["HealthCheckUpstream"];
        type?: components["parameters"]["HealthCheckReportType"];
        period?: components["parameters"]["ReportPeriod"];
        since?: components["parameters"]["ReportSince"];
        until?: components["parameters"]["ReportUntil"];
        direction?: components["parameters"]["Direction"];
        per_page?: components["parameters"]["PerPage"];
        page?: components["parameters"]["Page"];
      };
      path: {
        domain: components["parameters"]["Domain"];
      };
    };
    responses: {
      /** @description Successfully */
      200: {
        content: {
          "application/json": {
            data?: components["schemas"]["HealthCheckReportDetail"][];
          } & components["schemas"]["PaginatedResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Get list of all health-check zones */
  "health-checks.zones.index": {
    responses: {
      /** @description Successful */
      200: {
        content: {
          "application/json": {
            data?: components["schemas"]["HealthCheckZoneName"][];
          } & components["schemas"]["DataWithMessageResponse"];
        };
      };
    };
  };
  /** Get the list of Lists */
  "lists.index": {
    parameters: {
      query?: {
        per_page?: components["parameters"]["PerPage"];
        page?: components["parameters"]["Page"];
        scope?: components["parameters"]["DynamicFieldScope"];
        type?: components["parameters"]["DynamicFieldType"];
        name?: components["parameters"]["DynamicFieldName"];
      };
    };
    responses: {
      /** @description Successfully */
      200: {
        content: {
          "application/json": {
            data?: components["schemas"]["DynamicField"][];
          } & components["schemas"]["PaginatedResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Store new List */
  "lists.store": {
    requestBody?: {
      content: {
        "application/json": components["schemas"]["DynamicField"];
      };
    };
    responses: {
      /** @description Successfully created List */
      201: {
        content: {
          "application/json": components["schemas"]["DynamicFieldResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
  /** Get an existing List */
  "lists.show": {
    parameters: {
      path: {
        id: components["parameters"]["Id"];
      };
    };
    responses: {
      /** @description Successful */
      200: {
        content: {
          "application/json": components["schemas"]["DynamicFieldData"];
        };
      };
    };
  };
  /** Delete List */
  "lists.destroy": {
    parameters: {
      path: {
        id: components["parameters"]["Id"];
      };
    };
    responses: {
      /** @description Deleted successfully */
      200: components["responses"]["OK"];
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Update an existing List */
  "lists.update": {
    parameters: {
      path: {
        id: components["parameters"]["Id"];
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["DynamicField"];
      };
    };
    responses: {
      /** @description Successful */
      200: {
        content: {
          "application/json": components["schemas"]["DynamicFieldResponse"];
        };
      };
      401: components["responses"]["UnauthorizedError"];
      404: components["responses"]["NotFoundError"];
      422: components["responses"]["UnprocessableEntityError"];
    };
  };
}
